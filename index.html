<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Visual Patterns</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Outfit', sans-serif;
            cursor: crosshair;
        }
        
        #bg-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        #main-canvas { 
            display: block; 
            position: fixed; 
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        #info {
            position: fixed; 
            bottom: 24px; 
            left: 24px;
            color: rgba(255,255,255,0.6); 
            font-size: 13px; 
            font-weight: 300;
            letter-spacing: 0.02em;
            pointer-events: none; 
            transition: opacity 0.5s;
            text-shadow: 0 1px 8px rgba(0,0,0,0.6); 
            z-index: 100;
            line-height: 1.7;
        }
        
        #info.hidden { opacity: 0; pointer-events: none; }
        #info.hidden .control-btn { pointer-events: none; }
        
        .control-btn {
            display: inline-block;
            padding: 4px 10px;
            margin: 2px 4px 2px 0;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
        
        .control-btn:active {
            background: rgba(255,255,255,0.3);
            transform: scale(0.95);
        }
        
        .control-btn.active {
            background: rgba(100,150,255,0.3);
            border-color: rgba(100,150,255,0.5);
        }
        
        .hotkey {
            display: inline-block;
            padding: 1px 5px;
            margin-right: 4px;
            background: rgba(255,255,255,0.15);
            border-radius: 3px;
            font-size: 10px;
            font-weight: 500;
            opacity: 0.8;
        }
        
        @media (max-width: 768px), (hover: none) {
            .hotkey { display: none; }
        }
        
        #pattern-name {
            position: fixed; 
            top: 32px; 
            left: 50%; 
            transform: translateX(-50%);
            color: rgba(255,255,255,0.9); 
            font-size: 18px; 
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            pointer-events: none;
            text-shadow: 0 2px 20px rgba(0,0,0,0.5); 
            opacity: 0; 
            transition: opacity 0.8s ease; 
            z-index: 100;
        }
        
        #pattern-name.visible { opacity: 1; }
        
        .mouse-hint {
            position: fixed;
            bottom: 24px;
            right: 24px;
            color: rgba(255,255,255,0.4);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.05em;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .mouse-hint.hidden { opacity: 0; }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
    <div id="pattern-name"></div>
    <div id="info">
        <div>
            <span class="control-btn" data-action="next"><span class="hotkey">Space</span> Next</span>
            <span class="control-btn" data-action="wildcard"><span class="hotkey">W</span> Wildcard</span>
            <span class="control-btn" data-action="hide"><span class="hotkey">H</span> Hide UI</span>
            <span class="control-btn" data-action="sat2">SAT2</span>
        </div>
        <div style="margin-top: 6px;">
            <span class="control-btn" data-action="auto" id="auto-btn"><span class="hotkey">A</span> Auto: OFF</span>
            <span class="control-btn" data-action="pattern" data-pattern="0"><span class="hotkey">1</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="1"><span class="hotkey">2</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="2"><span class="hotkey">3</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="3"><span class="hotkey">4</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="4"><span class="hotkey">5</span></span>
        </div>
        <div style="margin-top: 6px;">
            <span class="control-btn" data-action="pattern" data-pattern="5"><span class="hotkey">6</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="6"><span class="hotkey">7</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="7"><span class="hotkey">8</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="8"><span class="hotkey">9</span></span>
            <span class="control-btn" data-action="pattern" data-pattern="9"><span class="hotkey">0</span></span>
            <span class="control-btn" data-action="lite" id="lite-btn">Lite: AUTO</span>
        </div>
    </div>
    <div class="mouse-hint">Click for SAT2 â€¢ Triple-click for TRDUTSCO</div>
    
    <script>
const CONFIG = {
    TIME_SCALE: 1.0,
    AUTO_CYCLE: false,
    AUTO_CYCLE_INTERVAL: 150000,
    COLOR: {
        SPEED: 0.06,
        SATURATION: 0.85,
        VALUE: 0.95,
        HUE_OFFSET: 0,
        RAINBOW_SPREAD: 1.2
    },
    VISUAL: {
        PULSE_SPEED: 0.4,
        PULSE_AMOUNT: 0.12,
        TWINKLE_SPEED: 2.5,
        TWINKLE_AMOUNT: 0.15,
        BASE_ALPHA: 0.75
    },
    MOTION: {
        CHAOS: 0.0,
        BREATHING: 0.0,
        WAVE_INTENSITY: 0.7
    },
    SPIRAL: {
        ROTATION_SPEED: 0.00125,
        SPIRAL_FACTOR: 0.015,
        WIGGLE_FREQ: 0.2,
        WIGGLE_AMP: 0.2
    },
    MOUSE: {
        INFLUENCE_RADIUS: 0.22,
        PUSH_STRENGTH: 0.025,
        HUE_SHIFT: 0.35
    },
    BACKGROUND: {
        NEBULA_INTENSITY: 0.5,
        STAR_COUNT: 150,
        SHOOTING_STAR_CHANCE: 0.002,
        PULSAR_COUNT: 3
    },
    TRANSITION: {
        DURATION: 2.0
    }
};

const { sin, cos, sqrt, floor, random, PI, pow, min, max, abs, atan2 } = Math;
const TAU = PI * 2;
const PHI = 1.618033988749;

function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, mn, mx) { return min(max(v, mn), mx); }
function smoothstep(t) { return t * t * (3 - 2 * t); }
function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2; }

function hsvToRgb(h, s, v) {
    h = ((h % 1) + 1) % 1;
    const i = floor(h * 6), f = h * 6 - i;
    const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: return [v, t, p]; case 1: return [q, v, p]; case 2: return [p, v, t];
        case 3: return [p, q, v]; case 4: return [t, p, v]; case 5: return [v, p, q];
    }
}

function roundTo(v, d = 3) { const m = pow(10, d); return Math.round(v * m) / m; }

// Canvases
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const mainCanvas = document.getElementById('main-canvas');
const ctx = mainCanvas.getContext('2d');

let width, height, minDim, scale;

function resize() {
    const dpr = min(window.devicePixelRatio || 1, 2);
    width = window.innerWidth;
    height = window.innerHeight;
    
    bgCanvas.width = width * dpr;
    bgCanvas.height = height * dpr;
    bgCanvas.style.width = width + 'px';
    bgCanvas.style.height = height + 'px';
    bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    mainCanvas.width = width * dpr;
    mainCanvas.height = height * dpr;
    mainCanvas.style.width = width + 'px';
    mainCanvas.style.height = height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    minDim = min(width, height);
    scale = minDim / 800;
    
    generateStars();
    generatePulsars();
}
window.addEventListener('resize', resize);

// Background elements
let stars = [];
let pulsars = [];
let shootingStars = [];
let lastBgUpdate = 0;

function generateStars() {
    stars = [];
    for (let i = 0; i < CONFIG.BACKGROUND.STAR_COUNT; i++) {
        stars.push({
            x: random() * width,
            y: random() * height,
            size: random() * 1.5 + 0.5,
            brightness: random() * 0.5 + 0.2,
            twinkleSpeed: random() * 2 + 0.5,
            twinklePhase: random() * TAU
        });
    }
}

function generatePulsars() {
    pulsars = [];
    for (let i = 0; i < CONFIG.BACKGROUND.PULSAR_COUNT; i++) {
        pulsars.push({
            x: random() * width,
            y: random() * height,
            size: random() * 2 + 1.5,
            speed: random() * 1.5 + 0.5,
            phase: random() * TAU,
            hue: random()
        });
    }
}

function updateShootingStars(t) {
    if (random() < CONFIG.BACKGROUND.SHOOTING_STAR_CHANCE) {
        shootingStars.push({
            x: random() * width * 1.2 - width * 0.1,
            y: -20,
            angle: PI * 0.15 + random() * PI * 0.2,
            speed: 400 + random() * 300,
            length: 80 + random() * 100,
            life: 0,
            maxLife: 1.5 + random(),
            brightness: 0.6 + random() * 0.4
        });
    }
    
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const star = shootingStars[i];
        star.life += 1/60;
        star.x += cos(star.angle) * star.speed / 60;
        star.y += sin(star.angle) * star.speed / 60;
        
        if (star.life > star.maxLife || star.y > height + 100) {
            shootingStars.splice(i, 1);
        }
    }
}

function drawBackground(t) {
    const now = performance.now();
    if (now - lastBgUpdate > 100) {
        lastBgUpdate = now;
        
        bgCtx.fillStyle = '#050508';
        bgCtx.fillRect(0, 0, width, height);
        
        const nebulaTime = t * 0.0004;
        
        bgCtx.globalAlpha = 0.15;
        bgCtx.fillStyle = '#4a1a6a';
        bgCtx.beginPath();
        bgCtx.arc(width * (0.3 + sin(nebulaTime) * 0.1), height * 0.35, width * 0.3, 0, TAU);
        bgCtx.fill();
        
        bgCtx.fillStyle = '#1a4a5a';
        bgCtx.beginPath();
        bgCtx.arc(width * (0.7 + cos(nebulaTime * 0.8) * 0.1), height * 0.6, width * 0.25, 0, TAU);
        bgCtx.fill();
        
        bgCtx.fillStyle = '#5a1a3a';
        bgCtx.beginPath();
        bgCtx.arc(width * (0.5 + sin(nebulaTime * 1.1) * 0.15), height * 0.75, width * 0.2, 0, TAU);
        bgCtx.fill();
        
        bgCtx.globalAlpha = 1;
    }
    
    for (const star of stars) {
        const twinkle = sin(t * star.twinkleSpeed + star.twinklePhase) * 0.3 + 0.7;
        const alpha = star.brightness * twinkle;
        bgCtx.fillStyle = `rgba(255,255,255,${alpha})`;
        bgCtx.fillRect(star.x, star.y, star.size, star.size);
    }
    
    for (const pulsar of pulsars) {
        const pulse = sin(t * pulsar.speed + pulsar.phase) * 0.5 + 0.5;
        const size = pulsar.size * (0.6 + pulse);
        const [r, g, b] = hsvToRgb(pulsar.hue, 0.5, 1);
        
        bgCtx.fillStyle = `rgba(${floor(r*255)},${floor(g*255)},${floor(b*255)},${0.3 + pulse * 0.5})`;
        bgCtx.beginPath();
        bgCtx.arc(pulsar.x, pulsar.y, size * 2, 0, TAU);
        bgCtx.fill();
        
        bgCtx.fillStyle = `rgba(255,255,255,${0.5 + pulse * 0.5})`;
        bgCtx.beginPath();
        bgCtx.arc(pulsar.x, pulsar.y, size * 0.5, 0, TAU);
        bgCtx.fill();
    }
    
    updateShootingStars(t);
    for (const star of shootingStars) {
        const progress = star.life / star.maxLife;
        const alpha = star.brightness * min(progress * 4, 1) * (1 - progress * progress);
        
        bgCtx.strokeStyle = `rgba(255,255,255,${alpha})`;
        bgCtx.lineWidth = 1.5;
        bgCtx.beginPath();
        bgCtx.moveTo(star.x - cos(star.angle) * star.length, star.y - sin(star.angle) * star.length);
        bgCtx.lineTo(star.x, star.y);
        bgCtx.stroke();
    }
}

resize();

// Mouse tracking
let mouse = { x: 0.5, y: 0.5, active: false };
let targetMouse = { x: 0.5, y: 0.5 };

document.addEventListener('mousemove', (e) => {
    targetMouse.x = e.clientX / width;
    targetMouse.y = e.clientY / height;
    mouse.active = true;
});

document.addEventListener('mouseleave', () => { mouse.active = false; });

document.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    targetMouse.x = touch.clientX / width;
    targetMouse.y = touch.clientY / height;
    mouse.active = true;
}, { passive: true });

document.addEventListener('touchend', () => { mouse.active = false; });

// Click detection for SAT2 / TRDUTSCO
let clickTimes = [];
let textFormationActive = false;
let textFormationStart = 0;
let currentTextTarget = 'SAT2';

const TEXT_FORMATION_DURATION = 3.5;
const TEXT_HOLD_DURATION = 4.0;
const TEXT_RELEASE_DURATION = 3.0;

// Mandala ring configuration for text formation
const MANDALA_RING_CONFIG = {
    ringCount: 3,           // Number of concentric rings
    particlesPerRing: [24, 36, 48],  // Particles in each ring
    baseRadius: [0.28, 0.38, 0.48],  // Radius of each ring (normalized)
    rotationSpeed: [0.4, -0.3, 0.25], // Rotation speed (alternating directions)
    pulseAmount: [0.03, 0.04, 0.05],  // How much the ring pulses
    pulseSpeed: [1.5, 2.0, 1.2]       // Pulse frequency
};

function generateTextAndArrowPoints(text, numPoints) {
    const points = [];
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 1200;
    tempCanvas.height = 600;
    
    const isMainText = text === 'SAT2';
    const fontSize = isMainText ? 320 : 180;
    
    tempCtx.fillStyle = '#fff';
    tempCtx.font = `bold ${fontSize}px "Outfit", sans-serif`;
    tempCtx.textAlign = 'center';
    tempCtx.textBaseline = 'middle';
    
    if (isMainText) {
        tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height * 0.35);
        
        tempCtx.beginPath();
        tempCtx.lineWidth = 24;
        tempCtx.lineCap = 'round';
        tempCtx.strokeStyle = '#fff';
        
        const smileStartX = tempCanvas.width * 0.22;
        const smileEndX = tempCanvas.width * 0.68;
        const smileY = tempCanvas.height * 0.72;
        const smileCurve = 55;
        
        tempCtx.moveTo(smileStartX, smileY);
        tempCtx.quadraticCurveTo(
            tempCanvas.width * 0.45, smileY + smileCurve,
            smileEndX, smileY - smileCurve * 0.3
        );
        tempCtx.stroke();
        
        const arrowX = tempCanvas.width * 0.74;
        const arrowY = smileY - smileCurve * 0.5;
        const arrowSize = 50;
        
        tempCtx.beginPath();
        tempCtx.lineWidth = 24;
        tempCtx.moveTo(arrowX - arrowSize * 0.3, arrowY + arrowSize * 0.5);
        tempCtx.lineTo(arrowX + arrowSize * 0.5, arrowY - arrowSize * 0.3);
        tempCtx.stroke();
        
        tempCtx.beginPath();
        tempCtx.moveTo(arrowX + arrowSize * 0.5, arrowY - arrowSize * 0.3);
        tempCtx.lineTo(arrowX, arrowY - arrowSize * 0.5);
        tempCtx.stroke();
        
        tempCtx.beginPath();
        tempCtx.moveTo(arrowX + arrowSize * 0.5, arrowY - arrowSize * 0.3);
        tempCtx.lineTo(arrowX + arrowSize * 0.7, arrowY + arrowSize * 0.1);
        tempCtx.stroke();
    } else {
        tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);
    }
    
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const pixels = imageData.data;
    
    const textPixels = [];
    const step = 2;
    for (let y = 0; y < tempCanvas.height; y += step) {
        for (let x = 0; x < tempCanvas.width; x += step) {
            const i = (y * tempCanvas.width + x) * 4;
            if (pixels[i + 3] > 128) {
                const normalizedX = x / tempCanvas.width;
                const normalizedY = y / tempCanvas.height;
                textPixels.push({
                    x: (normalizedX - 0.5) * 0.9 + 0.5,
                    y: (normalizedY - 0.5) * 0.6 + 0.5,
                    depth: sin(normalizedX * PI) * 0.025,
                    wave: random() * TAU,
                    type: 'text'
                });
            }
        }
    }
    
    // Calculate how many particles we need for mandala rings
    const totalMandalaParticles = MANDALA_RING_CONFIG.particlesPerRing.reduce((a, b) => a + b, 0);
    const textParticleCount = numPoints - totalMandalaParticles;
    
    // Assign text particles
    for (let i = 0; i < textParticleCount; i++) {
        if (textPixels.length > 0) {
            const idx = floor(random() * textPixels.length);
            points.push({ ...textPixels[idx] });
        } else {
            points.push({ x: 0.5, y: 0.5, depth: 0, wave: 0, type: 'text' });
        }
    }
    
    // Assign mandala ring particles
    let particleIndex = 0;
    for (let ring = 0; ring < MANDALA_RING_CONFIG.ringCount; ring++) {
        const particlesInRing = MANDALA_RING_CONFIG.particlesPerRing[ring];
        for (let i = 0; i < particlesInRing; i++) {
            const angle = (i / particlesInRing) * TAU;
            points.push({
                type: 'mandala',
                ring: ring,
                baseAngle: angle,
                baseRadius: MANDALA_RING_CONFIG.baseRadius[ring],
                rotationSpeed: MANDALA_RING_CONFIG.rotationSpeed[ring],
                pulseAmount: MANDALA_RING_CONFIG.pulseAmount[ring],
                pulseSpeed: MANDALA_RING_CONFIG.pulseSpeed[ring],
                wave: random() * TAU
            });
            particleIndex++;
        }
    }
    
    return points;
}

let textPoints = [];

function triggerTextFormation(text = 'SAT2') {
    if (textFormationActive) return;
    textFormationActive = true;
    textFormationStart = performance.now() / 1000;
    currentTextTarget = text;
    textPoints = generateTextAndArrowPoints(text, elements.length);
}

function handleClick(e) {
    if (e.target.classList.contains('control-btn')) return;
    
    const now = Date.now();
    clickTimes.push(now);
    
    clickTimes = clickTimes.filter(t => now - t < 600);
    
    if (clickTimes.length >= 3) {
        clickTimes = [];
        triggerTextFormation('TRDUTSCO');
    } else {
        setTimeout(() => {
            if (clickTimes.length > 0 && clickTimes.length < 3) {
                const timeSinceLast = Date.now() - clickTimes[clickTimes.length - 1];
                if (timeSinceLast > 300) {
                    clickTimes = [];
                    triggerTextFormation('SAT2');
                }
            }
        }, 350);
    }
}

document.addEventListener('click', handleClick);
document.addEventListener('touchstart', (e) => {
    if (e.target.classList.contains('control-btn')) return;
    handleClick(e);
}, { passive: true });

// Elements and patterns
let elements = [];
let currentPatternIndex = 0;
let previousPatternIndex = -1;
let transitionProgress = 1;
let transitionStartTime = 0;

function createElements(count) {
    elements = [];
    for (let i = 0; i < count; i++) {
        elements.push({
            index: i,
            phase: random() * TAU,
            twinklePhase: random() * TAU,
            colorOffset: random() * 0.1,
            sizeVariation: 0.85 + random() * 0.3,
            data: {},
            prevData: {},
            prevPos: { x: 0.5, y: 0.5, rotation: 0, scale: 0.5 }
        });
    }
}

function drawTriangle(x, y, size, rotation, hue, alpha) {
    if (size < 1 || alpha < 0.01) return;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    ctx.globalAlpha = alpha;
    
    const s = size;
    const lineWidth = s * 0.18;
    
    const [r, g, b] = hsvToRgb(hue, CONFIG.COLOR.SATURATION, CONFIG.COLOR.VALUE);
    ctx.strokeStyle = `rgb(${floor(r * 255)}, ${floor(g * 255)}, ${floor(b * 255)})`;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.beginPath();
    ctx.moveTo(0, -s);
    ctx.lineTo(-s * 0.866, s * 0.5);
    ctx.lineTo(s * 0.866, s * 0.5);
    ctx.closePath();
    ctx.stroke();
    
    ctx.restore();
}

// Pattern definitions
const PATTERNS = {
    storm: {
        name: "Particle Storm",
        elementCount: 2000,
        baseSize: 26,
        init: (el, count) => {
            const angle = random() * TAU;
            const radius = random() * 0.55;
            el.data = {
                x: 0.5 + cos(angle) * radius,
                y: 0.5 + sin(angle) * radius,
                vx: (random() - 0.5) * 0.003,
                vy: (random() - 0.5) * 0.003,
                homeAngle: (el.index / count) * TAU,
                tubeAngle: random() * TAU,
                tubeSpeed: 0.3 + random() * 0.4,
                initialized: false
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            
            const initialChaos = t < 8 ? 1 - smoothstep(t / 8) : 0;
            
            const cycleTime = 45;
            const phase = t % cycleTime;
            const sstep = (x) => x * x * (3 - 2 * x);
            
            let formationAmount = 0;
            let infinityAmount = 0;
            
            if (phase < 10) {
                formationAmount = sstep(phase / 10);
            } else if (phase < 20) {
                formationAmount = 1;
            } else if (phase < 25) {
                formationAmount = 1;
                infinityAmount = sstep((phase - 20) / 5);
            } else if (phase < 35) {
                formationAmount = 1;
                infinityAmount = 1;
            } else if (phase < 40) {
                formationAmount = 1;
                infinityAmount = 1 - sstep((phase - 35) / 5);
            } else {
                formationAmount = 1;
            }
            
            if (initialChaos > 0) {
                formationAmount = formationAmount * (1 - initialChaos);
            }
            
            const majorRadius = 0.38;
            const minorRadius = 0.1;
            const ringSpeed = 0.35;
            const tubeAngle = d.tubeAngle + t * d.tubeSpeed;
            const ringAngle = d.homeAngle + t * ringSpeed;
            
            const tilt = 0.45;
            const torusX = 0.5 + (majorRadius + minorRadius * cos(tubeAngle)) * cos(ringAngle);
            const torusY = 0.5 + (majorRadius + minorRadius * cos(tubeAngle)) * sin(ringAngle) * cos(tilt) 
                              - minorRadius * sin(tubeAngle) * sin(tilt);
            const depthScale = 0.7 + 0.3 * cos(tubeAngle);
            
            const infScale = 0.42;
            const infSpeed = 0.25;
            const infT = d.homeAngle + t * infSpeed;
            const denominator = 1 + sin(infT) * sin(infT);
            const infBaseX = (infScale * cos(infT)) / denominator;
            const infBaseY = (infScale * sin(infT) * cos(infT)) / denominator;
            const infTubeRadius = 0.07;
            const infX = 0.5 + infBaseX + cos(tubeAngle) * infTubeRadius * 0.5;
            const infY = 0.5 + infBaseY + sin(tubeAngle) * infTubeRadius;
            
            const targetX = lerp(torusX, infX, infinityAmount);
            const targetY = lerp(torusY, infY, infinityAmount);
            const targetScale = lerp(depthScale, 0.7 + 0.3 * cos(tubeAngle), infinityAmount);
            
            const chaosStrength = 1 - formationAmount;
            
            if (chaosStrength > 0.01) {
                const dx = 0.5 - d.x;
                const dy = 0.5 - d.y;
                
                const attract = 0.00008;
                d.vx += dx * attract;
                d.vy += dy * attract;
                
                const turb = cfg.MOTION.WAVE_INTENSITY * 0.0001;
                d.vx += sin(t * 2 + el.phase) * turb;
                d.vy += cos(t * 2 + el.phase + 1) * turb;
                
                d.vx *= 0.99;
                d.vy *= 0.99;
                d.x += d.vx * chaosStrength;
                d.y += d.vy * chaosStrength;
            }
            
            const lerpStrength = formationAmount * 0.06;
            d.x = lerp(d.x, targetX, lerpStrength);
            d.y = lerp(d.y, targetY, lerpStrength);
            
            if (d.x < -0.1) d.x = 1.1;
            if (d.x > 1.1) d.x = -0.1;
            if (d.y < -0.1) d.y = 1.1;
            if (d.y > 1.1) d.y = -0.1;
            
            const finalScale = lerp(0.4, targetScale * 0.6, formationAmount);
            
            return {
                x: d.x,
                y: d.y,
                rotation: t * 40,
                scale: finalScale + sin(t * 2.5 + el.phase) * 0.12
            };
        }
    },
    
    spiral: {
        name: "Spiral Galaxy",
        elementCount: 2200,
        baseSize: 28,
        init: (el, count) => {
            const goldenAngle = PI * (3 - sqrt(5));
            const i = el.index;
            el.data = {
                baseAngle: (i * goldenAngle) % TAU,
                baseRadius: 0.55 * pow(i / count, 0.7),
                speed: 0.5 + (i / count),
                armIndex: floor(i / (count / 5)) % 5
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const angleOffset = t * cfg.SPIRAL.ROTATION_SPEED * d.speed * 0.7;
            const spiralOffset = cfg.SPIRAL.SPIRAL_FACTOR * t * 0.7;
            
            const wiggleBase = sin(t * cfg.SPIRAL.WIGGLE_FREQ + el.index * 0.5);
            const wiggle = wiggleBase * cfg.SPIRAL.WIGGLE_AMP * cfg.MOTION.WAVE_INTENSITY;
            const smoothWiggle = pow(sin(t * 0.5), 2) * cfg.SPIRAL.WIGGLE_AMP * 0.3;
            const wiggleRotation = sin(t * 2 + el.phase) * 30;
            
            const breathe = sin(t * 0.3) * cfg.MOTION.BREATHING * 0.1;
            
            const currentAngle = d.baseAngle + angleOffset + spiralOffset;
            const radius = (d.baseRadius + wiggle + smoothWiggle) * (1 + breathe);
            const depthScale = 0.15 + (d.baseRadius / 0.55) * 0.95;
            
            const chaosX = sin(t * 7 + el.index) * cfg.MOTION.CHAOS * 0.05;
            const chaosY = cos(t * 7 + el.index * 1.3) * cfg.MOTION.CHAOS * 0.05;
            
            return {
                x: 0.5 + cos(currentAngle) * radius + chaosX,
                y: 0.5 + sin(currentAngle) * radius + chaosY,
                rotation: (angleOffset * 45) + 150 + wiggleRotation,
                scale: depthScale
            };
        }
    },
    
    rings: {
        name: "Ripple Rings",
        elementCount: 2000,
        baseSize: 32,
        init: (el, count) => {
            const ringCount = 12;
            const ring = floor(el.index / (count / ringCount));
            const posInRing = (el.index % (count / ringCount)) / (count / ringCount);
            el.data = {
                baseAngle: posInRing * TAU,
                baseRadius: (ring / ringCount) * 0.48 + 0.05,
                ring,
                posInRing
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const wave = sin(t * 2 - d.baseRadius * 15) * 0.03 * cfg.MOTION.WAVE_INTENSITY;
            const rotation = t * 0.35 + d.ring * 0.5;
            const angleOffset = rotation + d.posInRing * TAU;
            const radialWiggle = sin(t * 3 + d.ring * 2 + d.posInRing * 10) * 0.02;
            const pulse = sin(t * 3 + d.ring * 0.8) * 0.3;
            const breathe = sin(t * 0.3) * cfg.MOTION.BREATHING * 0.15;
            
            const radius = (d.baseRadius + wave + radialWiggle) * (1 + breathe);
            
            return {
                x: 0.5 + cos(angleOffset) * radius,
                y: 0.5 + sin(angleOffset) * radius,
                rotation: rotation * 100 + sin(t * 2 + d.ring) * 45,
                scale: 0.6 + pulse
            };
        }
    },
    
    pulseGrid: {
        name: "Pulse Grid",
        elementCount: 2025,
        baseSize: 28,
        init: (el, count) => {
            const gridSize = floor(sqrt(count));
            const row = floor(el.index / gridSize);
            const col = el.index % gridSize;
            const span = 1.1;
            const offset = (1 - span) / 2;
            const normX = col / (gridSize - 1);
            const normY = row / (gridSize - 1);
            el.data = {
                baseX: normX * span + offset,
                baseY: normY * span + offset,
                distFromCenter: sqrt(pow(normX - 0.5, 2) + pow(normY - 0.5, 2))
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const ripple = sin(t * 2.5 - d.distFromCenter * 8) * cfg.MOTION.WAVE_INTENSITY;
            const scalePulse = 0.5 + ripple * 0.25;
            const pullStrength = ripple * 0.035;
            const dx = (0.5 - d.baseX) * pullStrength;
            const dy = (0.5 - d.baseY) * pullStrength;
            
            return {
                x: d.baseX + dx,
                y: d.baseY + dy,
                rotation: ripple * 35 + t * 15,
                scale: scalePulse
            };
        }
    },
    
    grid: {
        name: "Flowing Grid",
        elementCount: 2500,
        baseSize: 36,
        init: (el, count) => {
            const gridSize = floor(sqrt(count));
            const row = floor(el.index / gridSize);
            const col = el.index % gridSize;
            const span = 1.1;
            const offset = (1 - span) / 2;
            el.data = {
                gridX: col / (gridSize - 1),
                gridY: row / (gridSize - 1),
                baseX: (col / (gridSize - 1)) * span + offset,
                baseY: (row / (gridSize - 1)) * span + offset
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const intensity = clamp(cfg.MOTION.WAVE_INTENSITY, 0, 1.0);
            
            const flowX = sin(t * 0.12 + d.gridY * 3) * 0.07 * intensity;
            const flowY = cos(t * 0.12 + d.gridX * 3) * 0.07 * intensity;
            
            const wave2X = sin(t * 0.2 + d.gridX * 5 + d.gridY * 2) * 0.025 * intensity;
            const wave2Y = cos(t * 0.2 + d.gridY * 5 + d.gridX * 2) * 0.025 * intensity;
            
            const wave = sin(t * 0.4 + d.gridX * 2 + d.gridY * 2) * 0.03;
            
            return {
                x: d.baseX + flowX + wave2X,
                y: d.baseY + flowY + wave2Y,
                rotation: t * 8 + (d.gridX + d.gridY) * 20 + sin(t * 0.5 + d.gridX * 3) * 15,
                scale: 0.5 + wave
            };
        }
    },
    
    orbits: {
        name: "Planetary Orbits",
        elementCount: 1920,
        baseSize: 35,
        init: (el, count) => {
            const orbitCount = 8;
            const orbit = floor(el.index / (count / orbitCount));
            const posInOrbit = (el.index % (count / orbitCount)) / (count / orbitCount);
            el.data = {
                orbit,
                orbitRadius: 0.06 + orbit * 0.05,
                angle: posInOrbit * TAU,
                orbitSpeed: 1.2 - orbit * 0.1,
                orbitPhase: orbit * 0.3
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const orbitAngle = t * d.orbitSpeed + d.angle;
            const breathe = 1 + sin(t * 0.3) * cfg.MOTION.BREATHING * 0.2;
            
            const ellipseA = d.orbitRadius * breathe;
            const ellipseB = d.orbitRadius * (0.75 + sin(t * 0.5 + d.orbitPhase) * 0.2) * breathe;
            
            const x = 0.5 + cos(orbitAngle) * ellipseA;
            const y = 0.5 + sin(orbitAngle) * ellipseB;
            
            const microOrbit = t * 2.5 + el.index * 0.08;
            const microRadius = 0.015;
            
            return {
                x: x + cos(microOrbit) * microRadius,
                y: y + sin(microOrbit) * microRadius,
                rotation: orbitAngle * 50 + microOrbit * 20,
                scale: 0.45 + sin(t * 2 + d.orbit) * 0.15 + abs(sin(orbitAngle)) * 0.1
            };
        }
    },
    
    fireworks: {
        name: "Fireworks Burst",
        elementCount: 1800,
        baseSize: 24,
        init: (el, count) => {
            const burstCount = 8;
            const burst = floor(el.index / (count / burstCount));
            const posInBurst = (el.index % (count / burstCount)) / (count / burstCount);
            const centers = [
                {x: 0.25, y: 0.25}, {x: 0.75, y: 0.25},
                {x: 0.5, y: 0.5}, {x: 0.25, y: 0.75},
                {x: 0.75, y: 0.75}, {x: 0.15, y: 0.5},
                {x: 0.85, y: 0.5}, {x: 0.5, y: 0.15}
            ];
            const center = centers[burst % centers.length];
            el.data = {
                burst,
                centerX: center.x,
                centerY: center.y,
                angle: posInBurst * TAU,
                speed: 0.3 + posInBurst * 0.7,
                life: posInBurst
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const burstTime = (t * 0.6 + d.burst * 0.5) % 3;
            let expansion = burstTime < 2 ? burstTime * 0.15 : (3 - burstTime) * 0.3;
            expansion *= cfg.MOTION.WAVE_INTENSITY;
            
            const gravity = burstTime * burstTime * 0.02;
            const spiralAngle = d.angle + burstTime * d.speed * 2;
            const radius = expansion * d.speed;
            
            const x = d.centerX + cos(spiralAngle) * radius;
            const y = d.centerY + sin(spiralAngle) * radius + gravity;
            
            const fade = burstTime < 2 ? (1 - burstTime / 2) : 0;
            const pulse = sin(t * 4 + d.life * 10) * 0.2;
            
            return {
                x, y,
                rotation: spiralAngle * 50 + t * 100,
                scale: (0.4 + fade * 0.6 + pulse) * d.speed
            };
        }
    },
    
    waves: {
        name: "Wave Interference",
        elementCount: 2500,
        baseSize: 32,
        init: (el, count) => {
            const gridSize = floor(sqrt(count));
            const row = floor(el.index / gridSize);
            const col = el.index % gridSize;
            const span = 1.1;
            const offset = (1 - span) / 2;
            el.data = {
                baseX: (col / (gridSize - 1)) * span + offset,
                baseY: (row / (gridSize - 1)) * span + offset
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const dx1 = d.baseX - 0.3, dy1 = d.baseY - 0.5;
            const dist1 = sqrt(dx1*dx1 + dy1*dy1);
            const dx2 = d.baseX - 0.7, dy2 = d.baseY - 0.5;
            const dist2 = sqrt(dx2*dx2 + dy2*dy2);
            
            const intensity = cfg.MOTION.WAVE_INTENSITY * 0.6;
            const wave1 = sin(t * 2.5 - dist1 * 15) * intensity;
            const wave2 = sin(t * 2.5 - dist2 * 15 + PI/3) * intensity;
            
            const interference = (wave1 + wave2) / 2;
            const offset = interference * 0.035;
            const circularMotion = sin(t * 1.2 + interference * PI) * 0.018;
            
            return {
                x: d.baseX + circularMotion,
                y: d.baseY + offset,
                rotation: t * 15 + interference * 60 + sin(t * 2) * 20,
                scale: 0.35 + (interference + 1) * 0.15 + sin(t * 3 + el.index * 0.1) * 0.08
            };
        }
    },
    
    helix: {
        name: "DNA Helix",
        elementCount: 1000,
        baseSize: 38,
        init: (el, count) => {
            el.data = {
                strand: el.index % 2,
                position: floor(el.index / 2) / floor(count / 2)
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const tOffset = t * 0.4;
            const helixAngle = d.position * PI * 4 + tOffset + d.strand * PI;
            const breathe = 1 + sin(t * 0.3) * cfg.MOTION.BREATHING * 0.3;
            const wiggle = sin(t * 2 + d.position * 10) * 0.03 * cfg.MOTION.WAVE_INTENSITY;
            const radiusWiggle = (0.18 + sin(t * 1.5 + d.position * 5) * 0.02) * breathe;
            
            const x = 0.5 + cos(helixAngle) * radiusWiggle + wiggle;
            const y = 0.02 + d.position * 0.96;
            const pulse = sin(d.position * 8 + t * 2) * 0.2;
            
            return {
                x, y,
                rotation: helixAngle * 50 + t * 30,
                scale: 0.4 + pulse + sin(t * 3 + d.strand * PI) * 0.15
            };
        }
    },
    
    vortex: {
        name: "Vortex",
        elementCount: 2000,
        baseSize: 26,
        init: (el, count) => {
            el.data = {
                height: el.index / count,
                baseAngle: (el.index / count) * TAU * 8,
                radiusMod: 0.8 + random() * 0.4
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            let radiusAtHeight = ((1 - d.height) * 0.4 + 0.05) * d.radiusMod;
            const spin = t * (0.3 + d.height * 0.5);
            const angle = d.baseAngle + spin;
            const wobble = sin(t * 1.5 + d.height * 10) * 0.02 * cfg.MOTION.WAVE_INTENSITY;
            const breathe = 1 + sin(t * 0.3) * cfg.MOTION.BREATHING * 0.2;
            const radius = radiusAtHeight * breathe + wobble;
            
            return {
                x: 0.5 + cos(angle) * radius,
                y: 0.02 + d.height * 0.96,
                rotation: angle * 30 + t * 15,
                scale: 0.3 + (1 - d.height) * 0.4
            };
        }
    },
    
    mandala: {
        name: "Mandala",
        elementCount: 2160,
        baseSize: 30,
        init: (el, count) => {
            const symmetry = 6;
            const segment = el.index % symmetry;
            const indexInSegment = floor(el.index / symmetry);
            const layer = floor(indexInSegment / 20);
            const posInLayer = (indexInSegment % 20) / 20;
            el.data = {
                segment,
                layer,
                posInLayer,
                baseRadius: 0.05 + layer * 0.045,
                symmetry
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const segmentAngle = (d.segment / d.symmetry) * TAU;
            const innerAngle = d.posInLayer * TAU / d.symmetry;
            const layerSpin = t * (0.5 - d.layer * 0.05) * (d.layer % 2 === 0 ? 1 : -1);
            const angle = segmentAngle + innerAngle + layerSpin;
            const breathe = 1 + sin(t * 0.4 + d.layer * 0.5) * cfg.MOTION.BREATHING * 0.15;
            const pulse = sin(t * 2 + d.layer * PI/3) * 0.02 * cfg.MOTION.WAVE_INTENSITY;
            const radius = (d.baseRadius + pulse) * breathe;
            
            return {
                x: 0.5 + cos(angle) * radius,
                y: 0.5 + sin(angle) * radius,
                rotation: layerSpin * 80 + d.layer * 30,
                scale: 0.4 + sin(t * 3 + d.layer) * 0.15
            };
        }
    },
    
    constellation: {
        name: "Constellation",
        elementCount: 1500,
        baseSize: 22,
        init: (el, count) => {
            const clusterCount = 12;
            const cluster = floor(random() * clusterCount);
            const clusterCenterX = (cluster % 4) / 3 * 0.7 + 0.15;
            const clusterCenterY = floor(cluster / 4) / 2 * 0.7 + 0.15;
            el.data = {
                baseX: clusterCenterX + (random() - 0.5) * 0.25,
                baseY: clusterCenterY + (random() - 0.5) * 0.25,
                twinkleSpeed: 2 + random() * 3,
                driftAngle: random() * TAU,
                driftSpeed: 0.005 + random() * 0.01
            };
        },
        update: (el, t, count, cfg) => {
            const d = el.data;
            const drift = sin(t * d.driftSpeed + d.driftAngle) * 0.03 * cfg.MOTION.WAVE_INTENSITY;
            const driftY = cos(t * d.driftSpeed * 0.7 + d.driftAngle) * 0.02;
            const twinkle = sin(t * d.twinkleSpeed + el.phase) * 0.5 + 0.5;
            
            return {
                x: d.baseX + drift,
                y: d.baseY + driftY,
                rotation: t * 10 + sin(t + el.index) * 20,
                scale: 0.3 + twinkle * 0.5
            };
        }
    }
};

const patternKeys = Object.keys(PATTERNS);

// Performance detection and lite mode
let liteMode = 'auto';
let frameTimings = [];
let performanceCheckDone = false;

const FULL_ELEMENT_COUNT = 2000;
const LITE_ELEMENT_COUNT = 800;

const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
const isSmallScreen = window.innerWidth < 1024 || window.innerHeight < 700;
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const isLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : false;

let isLiteModeActive = isMobile || (isTouchDevice && isSmallScreen) || isLowPower;

if (isLiteModeActive) {
    console.log('âš¡ Starting in Lite mode (mobile/touch/low-power detected)');
    performanceCheckDone = true;
}

function getElementCount() {
    return isLiteModeActive ? LITE_ELEMENT_COUNT : FULL_ELEMENT_COUNT;
}

function checkPerformance() {
    if (performanceCheckDone || liteMode !== 'auto') return;
    
    if (frameTimings.length >= 20) {
        const avgFrameTime = frameTimings.reduce((a, b) => a + b, 0) / frameTimings.length;
        const fps = 1000 / avgFrameTime;
        
        if (fps < 40) {
            console.log(`âš¡ Auto-enabling Lite mode (detected ${fps.toFixed(1)} FPS)`);
            isLiteModeActive = true;
            reinitializeElements();
            updateLiteButton();
        } else {
            console.log(`âœ¨ Performance OK (${fps.toFixed(1)} FPS)`);
        }
        performanceCheckDone = true;
    }
}

function toggleLiteMode() {
    if (liteMode === 'auto') {
        liteMode = 'on';
        isLiteModeActive = true;
    } else if (liteMode === 'on') {
        liteMode = 'off';
        isLiteModeActive = false;
    } else {
        liteMode = 'auto';
        isLiteModeActive = false;
        performanceCheckDone = false;
        frameTimings = [];
    }
    reinitializeElements();
    updateLiteButton();
}

function updateLiteButton() {
    const btn = document.getElementById('lite-btn');
    if (btn) {
        if (liteMode === 'auto') {
            btn.textContent = `Lite: AUTO${isLiteModeActive ? ' (ON)' : ''}`;
        } else {
            btn.textContent = `Lite: ${liteMode.toUpperCase()}`;
        }
        btn.classList.toggle('active', isLiteModeActive);
    }
}

function reinitializeElements() {
    const count = getElementCount();
    const pattern = PATTERNS[patternKeys[currentPatternIndex]];
    createElements(count);
    elements.forEach(el => pattern.init(el, count));
}

function initPattern(patternKey) {
    const pattern = PATTERNS[patternKey];
    const count = getElementCount();
    if (elements.length !== count) {
        createElements(count);
    }
    elements.forEach(el => {
        pattern.init(el, count);
    });
}

function switchPattern(index, smooth = true) {
    const newIndex = ((index % patternKeys.length) + patternKeys.length) % patternKeys.length;
    
    if (newIndex === currentPatternIndex) return;
    
    const count = getElementCount();
    
    if (smooth) {
        const currentPattern = PATTERNS[patternKeys[currentPatternIndex]];
        const t = performance.now() / 1000 * CONFIG.TIME_SCALE;
        
        elements.forEach((el, i) => {
            const pos = currentPattern.update(el, t, count, CONFIG);
            el.prevPos = { 
                x: pos.x, 
                y: pos.y, 
                rotation: pos.rotation, 
                scale: pos.scale 
            };
        });
        
        transitionProgress = 0;
        transitionStartTime = performance.now() / 1000;
    }
    
    currentPatternIndex = newIndex;
    
    const newPattern = PATTERNS[patternKeys[currentPatternIndex]];
    elements.forEach(el => {
        newPattern.init(el, count);
    });
    
    showPatternName(newPattern.name);
}

function nextPattern() {
    switchPattern(currentPatternIndex + 1, true);
}

function showPatternName(name) {
    const el = document.getElementById('pattern-name');
    el.textContent = name;
    el.classList.add('visible');
    setTimeout(() => el.classList.remove('visible'), 3000);
}

// Wildcard presets
const WILDCARD_PRESETS = [
    { name: "Calm Ocean", COLOR: { SPEED: 0.02, HUE_OFFSET: 0.55, SATURATION: 0.6 }, MOTION: { WAVE_INTENSITY: 0.5, BREATHING: 0.4, CHAOS: 0 } },
    { name: "Fire Storm", COLOR: { SPEED: 0.05, HUE_OFFSET: 0.0, RAINBOW_SPREAD: 0.2, SATURATION: 0.9 }, MOTION: { CHAOS: 0.08, WAVE_INTENSITY: 0.7 } },
    { name: "Ethereal", COLOR: { SPEED: 0.015, SATURATION: 0.45, VALUE: 1.0 }, VISUAL: { BASE_ALPHA: 0.6, TWINKLE_AMOUNT: 0.25 }, MOTION: { CHAOS: 0 } },
    { name: "Hyperdrive", TIME_SCALE: 1.2, COLOR: { SPEED: 0.07 }, MOTION: { WAVE_INTENSITY: 0.8, CHAOS: 0 } },
    { name: "Meditation", TIME_SCALE: 0.7, COLOR: { SPEED: 0.02 }, MOTION: { BREATHING: 0.5, CHAOS: 0, WAVE_INTENSITY: 0.4 } },
    { name: "Disco", COLOR: { SPEED: 0.09, RAINBOW_SPREAD: 1.3 }, VISUAL: { PULSE_SPEED: 0.5, PULSE_AMOUNT: 0.12 }, MOTION: { CHAOS: 0 } },
    { name: "Nebula", COLOR: { HUE_OFFSET: 0.75, SATURATION: 0.7, RAINBOW_SPREAD: 0.35 }, MOTION: { BREATHING: 0.4, CHAOS: 0 } },
    { name: "Gentle Flow", MOTION: { CHAOS: 0.05, WAVE_INTENSITY: 0.6 }, TIME_SCALE: 0.9 }
];

function applyWildcard() {
    if (random() > 0.5) {
        const preset = WILDCARD_PRESETS[floor(random() * WILDCARD_PRESETS.length)];
        console.log("ðŸŽ² Preset:", preset.name);
        for (const [cat, vals] of Object.entries(preset)) {
            if (cat === 'name') continue;
            if (typeof vals === 'object') {
                for (const [k, v] of Object.entries(vals)) {
                    if (CONFIG[cat]?.[k] !== undefined) CONFIG[cat][k] = v;
                }
            } else if (CONFIG[cat] !== undefined) {
                CONFIG[cat] = vals;
            }
        }
    } else {
        console.log("ðŸŽ² Random");
        CONFIG.TIME_SCALE = roundTo(0.7 + random() * 0.5);
        CONFIG.COLOR.SPEED = roundTo(0.02 + random() * 0.06);
        CONFIG.COLOR.HUE_OFFSET = roundTo(random());
        CONFIG.COLOR.SATURATION = roundTo(0.6 + random() * 0.3);
        CONFIG.COLOR.RAINBOW_SPREAD = roundTo(0.5 + random() * 0.8);
        CONFIG.VISUAL.PULSE_SPEED = roundTo(0.25 + random() * 0.4);
        CONFIG.VISUAL.PULSE_AMOUNT = roundTo(0.06 + random() * 0.1);
        CONFIG.MOTION.CHAOS = roundTo(random() * 0.1);
        CONFIG.MOTION.BREATHING = roundTo(random() * 0.3);
        CONFIG.MOTION.WAVE_INTENSITY = roundTo(0.4 + random() * 0.35);
    }
}

// Auto cycle
let autoCycleTimer = null;
function toggleAutoCycle() {
    CONFIG.AUTO_CYCLE = !CONFIG.AUTO_CYCLE;
    document.getElementById('auto-btn').textContent = `Auto: ${CONFIG.AUTO_CYCLE ? 'ON' : 'OFF'}`;
    document.getElementById('auto-btn').classList.toggle('active', CONFIG.AUTO_CYCLE);
    
    if (CONFIG.AUTO_CYCLE) {
        autoCycleTimer = setInterval(() => {
            nextPattern();
            if (random() > 0.6) applyWildcard();
        }, CONFIG.AUTO_CYCLE_INTERVAL);
    } else {
        clearInterval(autoCycleTimer);
    }
}

// Mouse influence
function getMouseInfluence(posX, posY) {
    if (!mouse.active) return { push: { x: 0, y: 0 }, hueShift: 0 };
    
    const dx = posX - mouse.x;
    const dy = posY - mouse.y;
    const dist = sqrt(dx * dx + dy * dy);
    const radius = CONFIG.MOUSE.INFLUENCE_RADIUS;
    
    if (dist < radius && dist > 0.001) {
        const t = 1 - dist / radius;
        const influence = t * t * t * CONFIG.MOUSE.PUSH_STRENGTH;
        const pushX = (dx / dist) * influence;
        const pushY = (dy / dist) * influence;
        const hueShift = t * t * CONFIG.MOUSE.HUE_SHIFT;
        
        return { push: { x: pushX, y: pushY }, hueShift };
    }
    
    return { push: { x: 0, y: 0 }, hueShift: 0 };
}

// Main render loop
const BASE_SIZE = 28;
let lastFrameTime = 0;

function render(timestamp) {
    if (lastFrameTime > 0) {
        const frameTime = timestamp - lastFrameTime;
        frameTimings.push(frameTime);
        if (frameTimings.length > 120) frameTimings.shift();
        checkPerformance();
    }
    lastFrameTime = timestamp;
    
    const t = (timestamp / 1000) * CONFIG.TIME_SCALE;
    
    mouse.x = lerp(mouse.x, targetMouse.x, 0.1);
    mouse.y = lerp(mouse.y, targetMouse.y, 0.1);
    
    if (!isLiteModeActive || timestamp % 2 < 1) {
        drawBackground(t);
    }
    
    ctx.clearRect(0, 0, width, height);
    
    const pattern = PATTERNS[patternKeys[currentPatternIndex]];
    const count = elements.length;
    const basePulse = 1 + sin(t * CONFIG.VISUAL.PULSE_SPEED) * CONFIG.VISUAL.PULSE_AMOUNT;
    const globalTwinkle = sin(t * CONFIG.VISUAL.TWINKLE_SPEED * 0.5) * 0.5 + 0.5;
    
    if (transitionProgress < 1) {
        const elapsed = timestamp / 1000 - transitionStartTime;
        transitionProgress = min(1, elapsed / CONFIG.TRANSITION.DURATION);
    }
    const transitionEase = easeInOutCubic(transitionProgress);
    
    // Handle text formation
    let textBlend = 0;
    if (textFormationActive) {
        const elapsed = timestamp / 1000 - textFormationStart;
        const totalDuration = TEXT_FORMATION_DURATION + TEXT_HOLD_DURATION + TEXT_RELEASE_DURATION;
        
        if (elapsed < TEXT_FORMATION_DURATION) {
            textBlend = easeInOutCubic(elapsed / TEXT_FORMATION_DURATION);
        } else if (elapsed < TEXT_FORMATION_DURATION + TEXT_HOLD_DURATION) {
            textBlend = 1;
        } else if (elapsed < totalDuration) {
            const releaseProgress = (elapsed - TEXT_FORMATION_DURATION - TEXT_HOLD_DURATION) / TEXT_RELEASE_DURATION;
            textBlend = 1 - easeInOutCubic(releaseProgress);
        } else {
            textFormationActive = false;
            textBlend = 0;
        }
    }
    
    for (let i = 0; i < count; i++) {
        const el = elements[i];
        let pos = pattern.update(el, t, count, CONFIG);
        
        if (transitionProgress < 1 && el.prevPos) {
            pos = {
                x: lerp(el.prevPos.x, pos.x, transitionEase),
                y: lerp(el.prevPos.y, pos.y, transitionEase),
                rotation: lerp(el.prevPos.rotation, pos.rotation, transitionEase),
                scale: lerp(el.prevPos.scale, pos.scale, transitionEase)
            };
        }
        
        // Blend with text/mandala position if active
        if (textBlend > 0 && textPoints[i]) {
            const pt = textPoints[i];
            
            if (pt.type === 'mandala') {
                // Mandala ring particle - orbit around center
                const ringTime = t * pt.rotationSpeed;
                const currentAngle = pt.baseAngle + ringTime;
                const pulse = sin(t * pt.pulseSpeed + pt.baseAngle) * pt.pulseAmount;
                const currentRadius = pt.baseRadius + pulse;
                
                // Add some wobble/shimmer to make it more interesting
                const shimmer = sin(t * 3 + pt.baseAngle * 3) * 0.008;
                const verticalWobble = cos(t * 2.5 + pt.baseAngle * 2) * 0.01;
                
                const mandalaX = 0.5 + cos(currentAngle) * (currentRadius + shimmer);
                const mandalaY = 0.5 + sin(currentAngle) * (currentRadius + shimmer) + verticalWobble;
                
                // Mandala particles spin faster
                const mandalaRotation = currentAngle * 80 + t * 60 + pt.ring * 30;
                
                // Scale based on ring - outer rings slightly smaller
                const mandalaScale = 0.25 - pt.ring * 0.03 + sin(t * 2 + pt.baseAngle) * 0.08;
                
                pos = {
                    x: lerp(pos.x, mandalaX, textBlend),
                    y: lerp(pos.y, mandalaY, textBlend),
                    scale: lerp(pos.scale, mandalaScale, textBlend),
                    rotation: lerp(pos.rotation, mandalaRotation, textBlend)
                };
            } else {
                // Text particle - original behavior
                const waveOffset = sin(t * 1.5 + pt.wave) * 0.006 * textBlend;
                const depthOffset = pt.depth * sin(t * 1.2) * textBlend;
                
                pos = {
                    x: lerp(pos.x, pt.x + waveOffset, textBlend),
                    y: lerp(pos.y, pt.y + depthOffset, textBlend),
                    scale: lerp(pos.scale, 0.16, textBlend),
                    rotation: lerp(pos.rotation, sin(t * 0.5 + pt.wave) * 8, textBlend)
                };
            }
        }
        
        const mouseEffect = getMouseInfluence(pos.x, pos.y);
        pos.x += mouseEffect.push.x;
        pos.y += mouseEffect.push.y;
        
        // Calculate hue - mandala particles get special rainbow treatment during text formation
        let hue;
        if (textBlend > 0 && textPoints[i] && textPoints[i].type === 'mandala') {
            const pt = textPoints[i];
            // Mandala rings get a beautiful rainbow effect based on angle
            const ringHue = (pt.baseAngle / TAU + t * 0.1 + pt.ring * 0.15) % 1;
            hue = lerp(
                (t * CONFIG.COLOR.SPEED + CONFIG.COLOR.HUE_OFFSET + (i / count) * CONFIG.COLOR.RAINBOW_SPREAD + el.colorOffset) % 1,
                ringHue,
                textBlend
            );
        } else {
            hue = (t * CONFIG.COLOR.SPEED + CONFIG.COLOR.HUE_OFFSET + (i / count) * CONFIG.COLOR.RAINBOW_SPREAD + el.colorOffset) % 1;
        }
        hue = (hue + mouseEffect.hueShift) % 1;
        
        const twinkle = 1 - ((sin(t * CONFIG.VISUAL.TWINKLE_SPEED + el.twinklePhase) * 0.5 + 0.5) * globalTwinkle * CONFIG.VISUAL.TWINKLE_AMOUNT);
        let finalScale = clamp(pos.scale * el.sizeVariation * basePulse, 0.15, 1.5);
        
        // Mandala particles glow brighter during formation
        let alpha;
        if (textBlend > 0 && textPoints[i] && textPoints[i].type === 'mandala') {
            alpha = clamp(CONFIG.VISUAL.BASE_ALPHA * twinkle * (1 + textBlend * 0.3), 0.2, 1.0);
        } else {
            alpha = clamp(CONFIG.VISUAL.BASE_ALPHA * twinkle, 0.2, 1.0);
        }
        
        drawTriangle(
            pos.x * width,
            pos.y * height,
            BASE_SIZE * finalScale * scale,
            pos.rotation * PI / 180,
            hue,
            alpha
        );
    }
    
    requestAnimationFrame(render);
}

// UI Controls
let uiVisible = true;

document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        
        switch(action) {
            case 'next':
                nextPattern();
                break;
            case 'wildcard':
                applyWildcard();
                break;
            case 'hide':
                uiVisible = !uiVisible;
                document.getElementById('info').classList.toggle('hidden', !uiVisible);
                document.querySelector('.mouse-hint').classList.toggle('hidden', !uiVisible);
                break;
            case 'sat2':
                triggerTextFormation('SAT2');
                break;
            case 'auto':
                toggleAutoCycle();
                break;
            case 'lite':
                toggleLiteMode();
                break;
            case 'pattern':
                switchPattern(parseInt(btn.dataset.pattern), true);
                break;
        }
    });
});

document.addEventListener('keydown', (e) => {
    switch(e.key.toLowerCase()) {
        case ' ':
            e.preventDefault();
            nextPattern();
            break;
        case 'w':
            applyWildcard();
            break;
        case 'h':
            uiVisible = !uiVisible;
            document.getElementById('info').classList.toggle('hidden', !uiVisible);
            document.querySelector('.mouse-hint').classList.toggle('hidden', !uiVisible);
            break;
        case 'a':
            toggleAutoCycle();
            break;
        case 'l':
            toggleLiteMode();
            break;
        case 'p':
            console.log('Current CONFIG:', JSON.stringify(CONFIG, null, 2));
            break;
        case '1': case '2': case '3': case '4': case '5':
        case '6': case '7': case '8': case '9': case '0':
            switchPattern(e.key === '0' ? 9 : parseInt(e.key) - 1, true);
            break;
    }
});

initPattern(patternKeys[0]);
updateLiteButton();
requestAnimationFrame(render);
console.log("âœ¨ Visualizer ready! Press L for Lite mode if performance is poor");
    </script>
</body>
</html>
