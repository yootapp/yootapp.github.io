<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Visual Patterns</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Outfit', sans-serif; cursor: crosshair; }
        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        #main-canvas { display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #info { position: fixed; bottom: 24px; left: 24px; color: rgba(255,255,255,0.6); font-size: 13px; font-weight: 300; letter-spacing: 0.02em; pointer-events: none; transition: opacity 0.5s; text-shadow: 0 1px 8px rgba(0,0,0,0.6); z-index: 100; line-height: 1.7; }
        #info.hidden { opacity: 0; pointer-events: none; }
        #info.hidden .control-btn { pointer-events: none; }
        .control-btn { display: inline-block; padding: 4px 10px; margin: 2px 4px 2px 0; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; font-family: 'Outfit', sans-serif; font-size: 12px; font-weight: 400; color: rgba(255,255,255,0.8); cursor: pointer; pointer-events: auto; transition: all 0.2s; user-select: none; -webkit-tap-highlight-color: transparent; }
        .control-btn:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.4); }
        .control-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }
        .control-btn.active { background: rgba(100,150,255,0.3); border-color: rgba(100,150,255,0.5); }
        .hotkey { display: inline-block; padding: 1px 5px; margin-right: 4px; background: rgba(255,255,255,0.15); border-radius: 3px; font-size: 10px; font-weight: 500; opacity: 0.8; }
        @media (max-width: 768px), (hover: none) { .hotkey { display: none; } }
        #pattern-name { position: fixed; top: 32px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.9); font-size: 18px; font-weight: 200; letter-spacing: 0.15em; text-transform: uppercase; pointer-events: none; text-shadow: 0 2px 20px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.8s ease; z-index: 100; }
        #pattern-name.visible { opacity: 1; }
        .mouse-hint { position: fixed; bottom: 24px; right: 24px; color: rgba(255,255,255,0.4); font-size: 11px; font-weight: 300; letter-spacing: 0.05em; pointer-events: none; z-index: 100; transition: opacity 0.5s; }
        .mouse-hint.hidden { opacity: 0; }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
    <div id="pattern-name"></div>
    <div id="info">
        <div>
            <span class="control-btn" data-action="prev"><span class="hotkey">←</span> Prev</span>
            <span class="control-btn" data-action="next"><span class="hotkey">→</span> Next</span>
            <span class="control-btn" data-action="random"><span class="hotkey">R</span> Random</span>
            <span class="control-btn" data-action="wildcard"><span class="hotkey">W</span> Wildcard</span>
        </div>
        <div style="margin-top: 6px;">
            <span class="control-btn" data-action="auto" id="auto-btn"><span class="hotkey">A</span> Auto: OFF</span>
            <span class="control-btn" data-action="sat2">SAT2</span>
            <span class="control-btn" data-action="hide"><span class="hotkey">H</span> Hide UI</span>
            <span class="control-btn" data-action="lite" id="lite-btn">Lite: AUTO</span>
        </div>
    </div>
    <div class="mouse-hint">Click for SAT2 • Triple-click for TRDUTSCO</div>
    
    <script>
// config
const cfg = {
    timeScale: 1.0, autoCycle: false, cycleInterval: 150000,
    color: { speed: 0.06, sat: 0.85, val: 0.95, hueOffset: 0, spread: 1.2 },
    visual: { pulseSpeed: 0.4, pulseAmt: 0.12, twinkleSpeed: 2.5, twinkleAmt: 0.15, baseAlpha: 0.75 },
    motion: { chaos: 0.0, breathing: 0.0, waveInt: 0.7 },
    spiral: { rotSpeed: 0.00125, factor: 0.015, wiggleFreq: 0.2, wiggleAmp: 0.2 },
    mouse: { radius: 0.22, push: 0.025, hueShift: 0.35 },
    bg: { starCount: 150, shootingChance: 0.002, pulsarCount: 3 },
    transition: { dur: 2.0 }
};

const { sin, cos, sqrt, floor, random, PI, pow, min, max, abs, atan2 } = Math;
const TAU = PI * 2;
const lerp = (a, b, t) => a + (b - a) * t;
const clamp = (v, lo, hi) => min(max(v, lo), hi);
const smoothstep = t => t * t * (3 - 2 * t);
const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2;
const round3 = (v, d = 3) => { const m = pow(10, d); return Math.round(v * m) / m; };

function hsv2rgb(h, s, v) {
    h = ((h % 1) + 1) % 1;
    const i = floor(h * 6), f = h * 6 - i;
    const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: return [v, t, p]; case 1: return [q, v, p]; case 2: return [p, v, t];
        case 3: return [p, q, v]; case 4: return [t, p, v]; case 5: return [v, p, q];
    }
}

// canvas setup
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const mainCanvas = document.getElementById('main-canvas');
const gl = mainCanvas.getContext('webgl2', { alpha: true, premultipliedAlpha: false, antialias: true });

if (!gl) { alert('WebGL2 not supported'); throw new Error('No WebGL2'); }

let w, h, minDim, scale;

// WebGL shaders
const vertSrc = `#version 300 es
precision highp float;
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aInstPos;
layout(location=2) in float aInstRot;
layout(location=3) in float aInstScale;
layout(location=4) in float aInstHue;
layout(location=5) in float aInstAlpha;
layout(location=6) in float aInstSat;
layout(location=7) in float aInstVal;

uniform vec2 uRes;

out vec3 vColor;
out float vAlpha;
out vec2 vLocalPos;

vec3 hsv2rgb(float h, float s, float v) {
    vec3 c = vec3(h, s, v);
    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
    return c.z * mix(vec3(1.0), rgb, c.y);
}

void main() {
    float c = cos(aInstRot), s = sin(aInstRot);
    mat2 rot = mat2(c, s, -s, c);
    vec2 scaled = aPos * aInstScale;
    vec2 rotated = rot * scaled;
    vec2 screen = (aInstPos + rotated / uRes) * 2.0 - 1.0;
    screen.y = -screen.y;
    gl_Position = vec4(screen, 0.0, 1.0);
    vColor = hsv2rgb(aInstHue, aInstSat, aInstVal);
    vAlpha = aInstAlpha;
    vLocalPos = aPos;
}`;

const fragSrc = `#version 300 es
precision highp float;
in vec3 vColor;
in float vAlpha;
in vec2 vLocalPos;
out vec4 fragColor;

float sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {
    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;
    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;
    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);
    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);
    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);
    float s = sign(e0.x * e2.y - e0.y * e2.x);
    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),
                     vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),
                     vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));
    return -sqrt(d.x) * sign(d.y);
}

void main() {
    vec2 p0 = vec2(0.0, -1.0), p1 = vec2(-0.866, 0.5), p2 = vec2(0.866, 0.5);
    float d = sdTriangle(vLocalPos, p0, p1, p2);
    
    // Original: lineWidth = size * 0.25, centered on edge
    float halfStroke = 0.125;
    
    // Stroke: centered on edge, smooth falloff
    float stroke = 1.0 - smoothstep(halfStroke - 0.02, halfStroke + 0.02, abs(d));
    
    // Fill: inside triangle
    float fill = 1.0 - smoothstep(-0.02, 0.02, d);
    
    // Combine: fill at 35%, stroke at full
    float finalAlpha = max(fill * 0.35, stroke) * vAlpha;
    
    if (finalAlpha < 0.01) discard;
    fragColor = vec4(vColor, finalAlpha);
}`;

function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        return null;
    }
    return s;
}

const vert = compileShader(vertSrc, gl.VERTEX_SHADER);
const frag = compileShader(fragSrc, gl.FRAGMENT_SHADER);
const prog = gl.createProgram();
gl.attachShader(prog, vert);
gl.attachShader(prog, frag);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);

const uRes = gl.getUniformLocation(prog, 'uRes');

// triangle geometry - single triangle
// Quad that encompasses triangle + stroke (2 triangles)
const triVerts = new Float32Array([
    -1.1, -1.2,  1.1, -1.2,  1.1, 0.7,  // first triangle
    -1.1, -1.2,  1.1, 0.7,  -1.1, 0.7   // second triangle
]);
const triBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, triBuf);
gl.bufferData(gl.ARRAY_BUFFER, triVerts, gl.STATIC_DRAW);

// instance buffers
const MAX_PARTICLES = 5000;
const instData = new Float32Array(MAX_PARTICLES * 7); // x,y,rot,scale,hue,alpha,sat,val packed
const instBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
gl.bufferData(gl.ARRAY_BUFFER, instData.byteLength, gl.DYNAMIC_DRAW);

// VAO setup
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// position attrib (per-vertex)
gl.bindBuffer(gl.ARRAY_BUFFER, triBuf);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

// instance attribs
gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
// aInstPos (x,y)
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 0);
gl.vertexAttribDivisor(1, 1);
// aInstRot
gl.enableVertexAttribArray(2);
gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 32, 8);
gl.vertexAttribDivisor(2, 1);
// aInstScale
gl.enableVertexAttribArray(3);
gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 12);
gl.vertexAttribDivisor(3, 1);
// aInstHue
gl.enableVertexAttribArray(4);
gl.vertexAttribPointer(4, 1, gl.FLOAT, false, 32, 16);
gl.vertexAttribDivisor(4, 1);
// aInstAlpha
gl.enableVertexAttribArray(5);
gl.vertexAttribPointer(5, 1, gl.FLOAT, false, 32, 20);
gl.vertexAttribDivisor(5, 1);
// aInstSat
gl.enableVertexAttribArray(6);
gl.vertexAttribPointer(6, 1, gl.FLOAT, false, 32, 24);
gl.vertexAttribDivisor(6, 1);
// aInstVal
gl.enableVertexAttribArray(7);
gl.vertexAttribPointer(7, 1, gl.FLOAT, false, 32, 28);
gl.vertexAttribDivisor(7, 1);

gl.bindVertexArray(null);

// blending
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

function resize() {
    const dpr = min(window.devicePixelRatio || 1, 2);
    w = window.innerWidth; h = window.innerHeight;
    bgCanvas.width = w * dpr; bgCanvas.height = h * dpr;
    bgCanvas.style.width = w + 'px'; bgCanvas.style.height = h + 'px';
    bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    mainCanvas.width = w * dpr; mainCanvas.height = h * dpr;
    mainCanvas.style.width = w + 'px'; mainCanvas.style.height = h + 'px';
    gl.viewport(0, 0, mainCanvas.width, mainCanvas.height);
    minDim = min(w, h); scale = minDim / 800;
    makeStars(); makePulsars();
}
window.addEventListener('resize', resize);

// background (still canvas2d - fine for static stuff)
let stars = [], pulsars = [], shootingStars = [], lastBgDraw = 0;

function makeStars() {
    stars = [];
    for (let i = 0; i < cfg.bg.starCount; i++) {
        stars.push({ x: random() * w, y: random() * h, size: random() * 1.5 + 0.5, bright: random() * 0.5 + 0.2, twinkleSpd: random() * 2 + 0.5, twinkleOff: random() * TAU });
    }
}

function makePulsars() {
    pulsars = [];
    for (let i = 0; i < cfg.bg.pulsarCount; i++) {
        pulsars.push({ x: random() * w, y: random() * h, size: random() * 2 + 1.5, spd: random() * 1.5 + 0.5, phase: random() * TAU, hue: random() });
    }
}

function tickShootingStars(t) {
    if (random() < cfg.bg.shootingChance) {
        shootingStars.push({ x: random() * w * 1.2 - w * 0.1, y: -20, angle: PI * 0.15 + random() * PI * 0.2, spd: 400 + random() * 300, len: 80 + random() * 100, life: 0, maxLife: 1.5 + random(), bright: 0.6 + random() * 0.4 });
    }
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const s = shootingStars[i];
        s.life += 1/60; s.x += cos(s.angle) * s.spd / 60; s.y += sin(s.angle) * s.spd / 60;
        if (s.life > s.maxLife || s.y > h + 100) shootingStars.splice(i, 1);
    }
}

function drawBg(t) {
    const now = performance.now();
    if (now - lastBgDraw > 100) {
        lastBgDraw = now;
        bgCtx.fillStyle = '#050508'; bgCtx.fillRect(0, 0, w, h);
        const nt = t * 0.0004;
        bgCtx.globalAlpha = 0.15;
        bgCtx.fillStyle = '#4a1a6a'; bgCtx.beginPath(); bgCtx.arc(w * (0.3 + sin(nt) * 0.1), h * 0.35, w * 0.3, 0, TAU); bgCtx.fill();
        bgCtx.fillStyle = '#1a4a5a'; bgCtx.beginPath(); bgCtx.arc(w * (0.7 + cos(nt * 0.8) * 0.1), h * 0.6, w * 0.25, 0, TAU); bgCtx.fill();
        bgCtx.fillStyle = '#5a1a3a'; bgCtx.beginPath(); bgCtx.arc(w * (0.5 + sin(nt * 1.1) * 0.15), h * 0.75, w * 0.2, 0, TAU); bgCtx.fill();
        bgCtx.globalAlpha = 1;
    }
    for (const star of stars) {
        const twinkle = sin(t * star.twinkleSpd + star.twinkleOff) * 0.3 + 0.7;
        bgCtx.fillStyle = `rgba(255,255,255,${star.bright * twinkle})`;
        bgCtx.fillRect(star.x, star.y, star.size, star.size);
    }
    for (const p of pulsars) {
        const pulse = sin(t * p.spd + p.phase) * 0.5 + 0.5;
        const sz = p.size * (0.6 + pulse);
        const [r, g, b] = hsv2rgb(p.hue, 0.5, 1);
        bgCtx.fillStyle = `rgba(${floor(r*255)},${floor(g*255)},${floor(b*255)},${0.3 + pulse * 0.5})`;
        bgCtx.beginPath(); bgCtx.arc(p.x, p.y, sz * 2, 0, TAU); bgCtx.fill();
        bgCtx.fillStyle = `rgba(255,255,255,${0.5 + pulse * 0.5})`;
        bgCtx.beginPath(); bgCtx.arc(p.x, p.y, sz * 0.5, 0, TAU); bgCtx.fill();
    }
    tickShootingStars(t);
    for (const s of shootingStars) {
        const prog = s.life / s.maxLife;
        const a = s.bright * min(prog * 4, 1) * (1 - prog * prog);
        bgCtx.strokeStyle = `rgba(255,255,255,${a})`; bgCtx.lineWidth = 1.5;
        bgCtx.beginPath(); bgCtx.moveTo(s.x - cos(s.angle) * s.len, s.y - sin(s.angle) * s.len);
        bgCtx.lineTo(s.x, s.y); bgCtx.stroke();
    }
}

resize();

// mouse
let mouse = { x: 0.5, y: 0.5, active: false }, mouseTarget = { x: 0.5, y: 0.5 };
document.addEventListener('mousemove', e => { mouseTarget.x = e.clientX / w; mouseTarget.y = e.clientY / h; mouse.active = true; });
document.addEventListener('mouseleave', () => { mouse.active = false; });
document.addEventListener('touchmove', e => { const touch = e.touches[0]; mouseTarget.x = touch.clientX / w; mouseTarget.y = touch.clientY / h; mouse.active = true; }, { passive: true });
document.addEventListener('touchend', () => { mouse.active = false; });

// text formation
let clickTimes = [], textActive = false, textStart = 0, textTarget = 'SAT2';
const TEXT_FORM_DUR = 3.5, TEXT_HOLD_DUR = 4.0, TEXT_RELEASE_DUR = 3.0;
const mandalaRings = { count: 3, perRing: [24, 36, 48], radius: [0.28, 0.38, 0.48], rotSpd: [0.4, -0.3, 0.25], pulseAmt: [0.03, 0.04, 0.05], pulseSpd: [1.5, 2.0, 1.2] };

function genTextPoints(text, numPts) {
    const pts = [], tmp = document.createElement('canvas'), tmpCtx = tmp.getContext('2d');
    tmp.width = 1400; tmp.height = 600;
    const isMain = text === 'SAT2', fontSize = isMain ? 300 : 160, spacing = isMain ? 35 : 25;
    tmpCtx.fillStyle = '#fff'; tmpCtx.font = `bold ${fontSize}px "Outfit", sans-serif`;
    tmpCtx.textBaseline = 'middle'; tmpCtx.textAlign = 'center';
    
    function drawSpaced(str, cx, cy) {
        let totalW = 0;
        for (let i = 0; i < str.length; i++) { totalW += tmpCtx.measureText(str[i]).width; if (i < str.length - 1) totalW += spacing; }
        let x = cx - totalW / 2;
        for (let i = 0; i < str.length; i++) { const ch = str[i], chW = tmpCtx.measureText(ch).width; tmpCtx.fillText(ch, x + chW / 2, cy); x += chW + spacing; }
    }
    
    if (isMain) {
        drawSpaced(text, tmp.width / 2, tmp.height * 0.35);
        tmpCtx.beginPath(); tmpCtx.lineWidth = 24; tmpCtx.lineCap = 'round'; tmpCtx.strokeStyle = '#fff';
        const smileX1 = tmp.width * 0.20, smileX2 = tmp.width * 0.65, smileY = tmp.height * 0.72, curve = 55;
        tmpCtx.moveTo(smileX1, smileY); tmpCtx.quadraticCurveTo(tmp.width * 0.42, smileY + curve, smileX2, smileY - curve * 0.3); tmpCtx.stroke();
        const arrX = tmp.width * 0.71, arrY = smileY - curve * 0.5, arrSz = 50;
        tmpCtx.beginPath(); tmpCtx.lineWidth = 24; tmpCtx.moveTo(arrX - arrSz * 0.3, arrY + arrSz * 0.5); tmpCtx.lineTo(arrX + arrSz * 0.5, arrY - arrSz * 0.3); tmpCtx.stroke();
        tmpCtx.beginPath(); tmpCtx.moveTo(arrX + arrSz * 0.5, arrY - arrSz * 0.3); tmpCtx.lineTo(arrX, arrY - arrSz * 0.5); tmpCtx.stroke();
        tmpCtx.beginPath(); tmpCtx.moveTo(arrX + arrSz * 0.5, arrY - arrSz * 0.3); tmpCtx.lineTo(arrX + arrSz * 0.7, arrY + arrSz * 0.1); tmpCtx.stroke();
    } else { drawSpaced(text, tmp.width / 2, tmp.height / 2); }
    
    const imgData = tmpCtx.getImageData(0, 0, tmp.width, tmp.height), px = imgData.data, textPx = [], step = 2;
    for (let y = 0; y < tmp.height; y += step) {
        for (let x = 0; x < tmp.width; x += step) {
            const i = (y * tmp.width + x) * 4;
            if (px[i + 3] > 128) { const nx = x / tmp.width, ny = y / tmp.height;
                textPx.push({ x: (nx - 0.5) * 0.95 + 0.5, y: (ny - 0.5) * 0.6 + 0.5, depth: sin(nx * PI) * 0.025, wave: random() * TAU, type: 'text' }); }
        }
    }
    const totalMandala = mandalaRings.perRing.reduce((a, b) => a + b, 0), textCount = numPts - totalMandala;
    for (let i = 0; i < textCount; i++) { if (textPx.length > 0) { pts.push({ ...textPx[floor(random() * textPx.length)] }); } else { pts.push({ x: 0.5, y: 0.5, depth: 0, wave: 0, type: 'text' }); } }
    for (let ring = 0; ring < mandalaRings.count; ring++) { const n = mandalaRings.perRing[ring];
        for (let i = 0; i < n; i++) { const angle = (i / n) * TAU;
            pts.push({ type: 'mandala', ring, baseAngle: angle, baseRadius: mandalaRings.radius[ring], rotSpd: mandalaRings.rotSpd[ring], pulseAmt: mandalaRings.pulseAmt[ring], pulseSpd: mandalaRings.pulseSpd[ring], wave: random() * TAU }); } }
    return pts;
}

let textPts = [];
function triggerText(text = 'SAT2') { if (textActive) return; textActive = true; textStart = performance.now() / 1000; textTarget = text; textPts = genTextPoints(text, elements.length); }

function handleClick(e) {
    if (e.target.classList.contains('control-btn')) return;
    const now = Date.now(); clickTimes.push(now); clickTimes = clickTimes.filter(t => now - t < 600);
    if (clickTimes.length >= 3) { clickTimes = []; triggerText('TRDUTSCO'); }
    else { setTimeout(() => { if (clickTimes.length > 0 && clickTimes.length < 3) { const since = Date.now() - clickTimes[clickTimes.length - 1]; if (since > 300) { clickTimes = []; triggerText('SAT2'); } } }, 350); }
}
document.addEventListener('click', handleClick);
document.addEventListener('touchstart', e => { if (e.target.classList.contains('control-btn')) return; handleClick(e); }, { passive: true });

// particles
let elements = [], curPattern = 0, transitionProg = 1, transitionStart = 0;

function makeElements(count) {
    elements = [];
    for (let i = 0; i < count; i++) {
        elements.push({ idx: i, phase: random() * TAU, twinklePhase: random() * TAU, colorOff: random() * 0.1, sizeVar: 0.85 + random() * 0.3, data: {}, prevPos: { x: 0.5, y: 0.5, rot: 0, scale: 0.5 } });
    }
}

// boat scene
const boatScene = {
    boatPts: [], seaPts: [], skyPts: [],
    init(n) {
        this.boatPts = []; this.seaPts = []; this.skyPts = [];
        for (let i = 0; i <= 40; i++) { const t = i / 40, x = -0.12 + t * 0.24, y = 0.018 * (1 - pow((t - 0.5) * 2, 2)); this.boatPts.push({ x, y, part: 'hull' }); }
        for (let i = 0; i < 80; i++) { const t = random(), x = -0.11 + t * 0.22, maxY = 0.016 * (1 - pow((t - 0.5) * 2, 2)); this.boatPts.push({ x, y: random() * maxY - 0.003, part: 'hull' }); }
        for (let i = 0; i < 25; i++) { this.boatPts.push({ x: -0.005 + random() * 0.01, y: -i / 25 * 0.2 - 0.01, part: 'mast' }); }
        for (let i = 0; i < 120; i++) { let r1 = random(), r2 = random(); if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
            const x1 = 0.008, y1 = -0.20, x2 = 0.008, y2 = -0.02, x3 = 0.12, y3 = -0.05;
            this.boatPts.push({ x: x1 + r1 * (x2 - x1) + r2 * (x3 - x1), y: y1 + r1 * (y2 - y1) + r2 * (y3 - y1), part: 'sail' }); }
        for (let i = 0; i < 20; i++) { let r1 = random(), r2 = random(); if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
            this.boatPts.push({ x: -0.005 + r1 * 0.05 + r2 * 0.04, y: -0.20 + r2 * 0.03, part: 'flag' }); }
        const seaCount = floor(n * 0.45), rows = 10, perRow = floor(seaCount / rows);
        for (let row = 0; row < rows; row++) { for (let i = 0; i < perRow; i++) { this.seaPts.push({ baseX: i / perRow + random() * 0.02, row, depth: row / rows, phase: random() * TAU, spd: 0.8 + random() * 0.3 }); } }
        const skyCount = n - this.boatPts.length - this.seaPts.length;
        for (let i = 0; i < skyCount; i++) { this.skyPts.push({ x: random(), y: random() * 0.4, twinkleSpd: 1 + random() * 2, phase: random() * TAU, size: 0.15 + random() * 0.15 }); }
    },
    getWaveY(x, t, row) { const baseY = 0.54 + row * 0.042, amp = 0.022 - row * 0.001, freq = 2.2 + row * 0.2, spd = 0.5 + row * 0.03; return baseY + sin(x * freq * TAU + t * spd + row * 0.6) * amp; },
    getBoatPos(t) { const bx = 0.38 + sin(t * 0.12) * 0.12, by = this.getWaveY(bx, t, 0), dx = 0.015;
        const y1 = this.getWaveY(bx - dx, t, 0), y2 = this.getWaveY(bx + dx, t, 0);
        return { x: bx, y: by - 0.028, tilt: atan2(y2 - y1, dx * 2) * 0.5 }; },
    update(idx, t) {
        const bp = this.boatPts, sp = this.seaPts, boat = this.getBoatPos(t);
        if (idx < bp.length) {
            const pt = bp[idx], cosT = cos(boat.tilt), sinT = sin(boat.tilt);
            let sway = 0; if (pt.part === 'sail') sway = sin(t * 1.8 + pt.y * 8) * 0.006; if (pt.part === 'flag') sway = sin(t * 3 + pt.y * 5) * 0.012;
            const rx = (pt.x + sway) * cosT - pt.y * sinT, ry = (pt.x + sway) * sinT + pt.y * cosT;
            let hue, sat; if (pt.part === 'hull' || pt.part === 'mast') { hue = 0.07; sat = 0.55; } else if (pt.part === 'sail') { hue = 0.12; sat = 0.08; } else { hue = 0.0; sat = 0.85; }
            return { x: boat.x + rx, y: boat.y + ry, rot: boat.tilt + t * 3, scale: pt.part === 'flag' ? 0.22 : 0.32, hue, sat, val: 0.95, alpha: 0.9 };
        }
        const seaIdx = idx - bp.length;
        if (seaIdx < sp.length) {
            const pt = sp[seaIdx], x = pt.baseX, y = this.getWaveY(x, t * pt.spd, pt.row);
            const distToBoat = abs(x - boat.x), nearBoat = distToBoat < 0.14 && pt.row < 2;
            return { x, y: y + pt.depth * 0.015, rot: t * 8 + pt.phase * 30, scale: 0.3 - pt.depth * 0.08, hue: 0.55 + pt.depth * 0.06, sat: 0.65 - pt.depth * 0.1, val: 0.85 - pt.depth * 0.15, alpha: nearBoat ? 0.15 : (0.75 - pt.depth * 0.25) };
        }
        const skyIdx = seaIdx - sp.length;
        if (skyIdx < this.skyPts.length) { const pt = this.skyPts[skyIdx], twinkle = sin(t * pt.twinkleSpd + pt.phase) * 0.4 + 0.6;
            return { x: pt.x, y: pt.y + sin(t * 0.2 + pt.phase) * 0.008, rot: t * 4, scale: pt.size * twinkle, hue: 0.13, sat: 0.25, val: 1, alpha: twinkle * 0.5 }; }
        return { x: -1, y: -1, scale: 0, alpha: 0 };
    },
    drawBg(t) {
        const grad = bgCtx.createLinearGradient(0, 0, 0, h * 0.58);
        grad.addColorStop(0, '#080818'); grad.addColorStop(0.4, '#151530'); grad.addColorStop(1, '#253050');
        bgCtx.fillStyle = grad; bgCtx.fillRect(0, 0, w, h);
        const mx = w * 0.78, my = h * 0.14, mr = min(w, h) * 0.055;
        const glow = bgCtx.createRadialGradient(mx, my, 0, mx, my, mr * 4);
        glow.addColorStop(0, 'rgba(255, 250, 220, 0.25)'); glow.addColorStop(0.4, 'rgba(255, 250, 220, 0.08)'); glow.addColorStop(1, 'rgba(255, 250, 220, 0)');
        bgCtx.fillStyle = glow; bgCtx.beginPath(); bgCtx.arc(mx, my, mr * 4, 0, TAU); bgCtx.fill();
        bgCtx.fillStyle = '#fffae8'; bgCtx.beginPath(); bgCtx.arc(mx, my, mr, 0, TAU); bgCtx.fill();
        for (let layer = 7; layer >= 0; layer--) {
            const baseY = h * (0.54 + layer * 0.042), amp = h * (0.022 - layer * 0.001), freq = 2.2 + layer * 0.2, spd = 0.5 + layer * 0.03;
            bgCtx.fillStyle = `hsl(205, 65%, ${32 - layer * 2.5}%)`; bgCtx.beginPath(); bgCtx.moveTo(0, h);
            for (let x = 0; x <= w; x += 4) { bgCtx.lineTo(x, baseY + sin(x / w * freq * TAU + t * spd + layer * 0.6) * amp); }
            bgCtx.lineTo(w, h); bgCtx.closePath(); bgCtx.fill();
        }
        const ry = h * 0.60; bgCtx.globalAlpha = 0.3;
        for (let i = 0; i < 6; i++) { const rx = mx + sin(t * 1.5 + i * 0.8) * 12, rry = ry + i * 12 + sin(t * 1.2 + i * 0.4) * 4, rw = (25 - i * 3) + sin(t * 2 + i) * 5;
            bgCtx.fillStyle = 'rgba(255, 250, 220, 0.4)'; bgCtx.fillRect(rx - rw/2, rry, rw, 2); }
        bgCtx.globalAlpha = 1;
    }
};

// patterns
const patterns = {
    storm: { name: "Particle Storm", count: 2000, baseSize: 26,
        init: (el, n) => { const ang = random() * TAU, r = random() * 0.55;
            el.data = { x: 0.5 + cos(ang) * r, y: 0.5 + sin(ang) * r, vx: (random() - 0.5) * 0.003, vy: (random() - 0.5) * 0.003, homeAngle: (el.idx / n) * TAU, tubeAngle: random() * TAU, tubeSpd: 0.3 + random() * 0.4 }; },
        update: (el, t, n) => {
            const d = el.data, initChaos = t < 8 ? 1 - smoothstep(t / 8) : 0, cycle = 45, phase = t % cycle, ss = x => x * x * (3 - 2 * x);
            let formation = 0, infinity = 0;
            if (phase < 10) formation = ss(phase / 10); else if (phase < 20) formation = 1; else if (phase < 25) { formation = 1; infinity = ss((phase - 20) / 5); }
            else if (phase < 35) { formation = 1; infinity = 1; } else if (phase < 40) { formation = 1; infinity = 1 - ss((phase - 35) / 5); } else formation = 1;
            if (initChaos > 0) formation *= (1 - initChaos);
            const majR = 0.38, minR = 0.1, ringSpd = 0.35, tubeAng = d.tubeAngle + t * d.tubeSpd, ringAng = d.homeAngle + t * ringSpd, tilt = 0.45;
            const torusX = 0.5 + (majR + minR * cos(tubeAng)) * cos(ringAng), torusY = 0.5 + (majR + minR * cos(tubeAng)) * sin(ringAng) * cos(tilt) - minR * sin(tubeAng) * sin(tilt);
            const depthScale = 0.7 + 0.3 * cos(tubeAng), infScale = 0.42, infSpd = 0.25, infT = d.homeAngle + t * infSpd, denom = 1 + sin(infT) * sin(infT);
            const infX = 0.5 + (infScale * cos(infT)) / denom + cos(tubeAng) * 0.035, infY = 0.5 + (infScale * sin(infT) * cos(infT)) / denom + sin(tubeAng) * 0.07;
            const targetX = lerp(torusX, infX, infinity), targetY = lerp(torusY, infY, infinity), targetScale = lerp(depthScale, 0.7 + 0.3 * cos(tubeAng), infinity);
            const chaosStr = 1 - formation;
            if (chaosStr > 0.01) { d.vx += (0.5 - d.x) * 0.00008 + sin(t * 2 + el.phase) * cfg.motion.waveInt * 0.0001; d.vy += (0.5 - d.y) * 0.00008 + cos(t * 2 + el.phase + 1) * cfg.motion.waveInt * 0.0001;
                d.vx *= 0.99; d.vy *= 0.99; d.x += d.vx * chaosStr; d.y += d.vy * chaosStr; }
            d.x = lerp(d.x, targetX, formation * 0.06); d.y = lerp(d.y, targetY, formation * 0.06);
            if (d.x < -0.1) d.x = 1.1; if (d.x > 1.1) d.x = -0.1; if (d.y < -0.1) d.y = 1.1; if (d.y > 1.1) d.y = -0.1;
            return { x: d.x, y: d.y, rot: t * 40, scale: lerp(0.4, targetScale * 0.6, formation) + sin(t * 2.5 + el.phase) * 0.12 }; }
    },
    spiral: { name: "Spiral Galaxy", count: 2200, baseSize: 28,
        init: (el, n) => { const goldenAng = PI * (3 - sqrt(5)); el.data = { baseAngle: (el.idx * goldenAng) % TAU, baseRadius: 0.55 * pow(el.idx / n, 0.7), spd: 0.5 + (el.idx / n) }; },
        update: (el, t, n) => { const d = el.data, angleOff = t * cfg.spiral.rotSpeed * d.spd * 0.7, spiralOff = cfg.spiral.factor * t * 0.7;
            const wiggle = sin(t * cfg.spiral.wiggleFreq + el.idx * 0.5) * cfg.spiral.wiggleAmp * cfg.motion.waveInt + pow(sin(t * 0.5), 2) * cfg.spiral.wiggleAmp * 0.3;
            const r = (d.baseRadius + wiggle) * (1 + sin(t * 0.3) * cfg.motion.breathing * 0.1), curAngle = d.baseAngle + angleOff + spiralOff;
            return { x: 0.5 + cos(curAngle) * r + sin(t * 7 + el.idx) * cfg.motion.chaos * 0.05, y: 0.5 + sin(curAngle) * r + cos(t * 7 + el.idx * 1.3) * cfg.motion.chaos * 0.05,
                rot: (angleOff * 45) + 150 + sin(t * 2 + el.phase) * 30, scale: 0.15 + (d.baseRadius / 0.55) * 0.95 }; }
    },
    rings: { name: "Ripple Rings", count: 2000, baseSize: 32,
        init: (el, n) => { const ringCount = 12, ring = floor(el.idx / (n / ringCount)), pos = (el.idx % (n / ringCount)) / (n / ringCount);
            el.data = { baseAngle: pos * TAU, baseRadius: (ring / ringCount) * 0.48 + 0.05, ring, pos }; },
        update: (el, t, n) => { const d = el.data, wave = sin(t * 2 - d.baseRadius * 15) * 0.03 * cfg.motion.waveInt, rot = t * 0.35 + d.ring * 0.5;
            const r = (d.baseRadius + wave + sin(t * 3 + d.ring * 2 + d.pos * 10) * 0.02) * (1 + sin(t * 0.3) * cfg.motion.breathing * 0.15);
            return { x: 0.5 + cos(rot + d.pos * TAU) * r, y: 0.5 + sin(rot + d.pos * TAU) * r, rot: rot * 100 + sin(t * 2 + d.ring) * 45, scale: 0.6 + sin(t * 3 + d.ring * 0.8) * 0.3 }; }
    },
    pulseGrid: { name: "Pulse Grid", count: 2025, baseSize: 28,
        init: (el, n) => { const gridSz = floor(sqrt(n)), row = floor(el.idx / gridSz), col = el.idx % gridSz, span = 1.1, off = (1 - span) / 2;
            el.data = { baseX: (col / (gridSz - 1)) * span + off, baseY: (row / (gridSz - 1)) * span + off, distCenter: sqrt(pow(col / (gridSz - 1) - 0.5, 2) + pow(row / (gridSz - 1) - 0.5, 2)) }; },
        update: (el, t, n) => { const d = el.data, ripple = sin(t * 2.5 - d.distCenter * 8) * cfg.motion.waveInt, pull = ripple * 0.035;
            return { x: d.baseX + (0.5 - d.baseX) * pull, y: d.baseY + (0.5 - d.baseY) * pull, rot: ripple * 35 + t * 15, scale: 0.5 + ripple * 0.25 }; }
    },
    grid: { name: "Flowing Grid", count: 2500, baseSize: 36,
        init: (el, n) => { const gridSz = floor(sqrt(n)), row = floor(el.idx / gridSz), col = el.idx % gridSz, span = 1.1, off = (1 - span) / 2;
            el.data = { gx: col / (gridSz - 1), gy: row / (gridSz - 1), baseX: (col / (gridSz - 1)) * span + off, baseY: (row / (gridSz - 1)) * span + off }; },
        update: (el, t, n) => { const d = el.data, int = clamp(cfg.motion.waveInt, 0, 1);
            return { x: d.baseX + sin(t * 0.12 + d.gy * 3) * 0.07 * int + sin(t * 0.2 + d.gx * 5 + d.gy * 2) * 0.025 * int,
                y: d.baseY + cos(t * 0.12 + d.gx * 3) * 0.07 * int + cos(t * 0.2 + d.gy * 5 + d.gx * 2) * 0.025 * int,
                rot: t * 8 + (d.gx + d.gy) * 20 + sin(t * 0.5 + d.gx * 3) * 15, scale: 0.5 + sin(t * 0.4 + d.gx * 2 + d.gy * 2) * 0.03 }; }
    },
    orbits: { name: "Planetary Orbits", count: 1920, baseSize: 35,
        init: (el, n) => { const orbitCount = 8, orbit = floor(el.idx / (n / orbitCount)), pos = (el.idx % (n / orbitCount)) / (n / orbitCount);
            el.data = { orbit, orbitR: 0.06 + orbit * 0.05, angle: pos * TAU, orbitSpd: 1.2 - orbit * 0.1, orbitPhase: orbit * 0.3 }; },
        update: (el, t, n) => { const d = el.data, orbitAng = t * d.orbitSpd + d.angle, breathe = 1 + sin(t * 0.3) * cfg.motion.breathing * 0.2;
            const a = d.orbitR * breathe, b = d.orbitR * (0.75 + sin(t * 0.5 + d.orbitPhase) * 0.2) * breathe, micro = t * 2.5 + el.idx * 0.08;
            return { x: 0.5 + cos(orbitAng) * a + cos(micro) * 0.015, y: 0.5 + sin(orbitAng) * b + sin(micro) * 0.015,
                rot: orbitAng * 50 + micro * 20, scale: 0.45 + sin(t * 2 + d.orbit) * 0.15 + abs(sin(orbitAng)) * 0.1 }; }
    },
    fireworks: { name: "Fireworks Burst", count: 1800, baseSize: 24,
        init: (el, n) => { const burstCount = 8, burst = floor(el.idx / (n / burstCount)), pos = (el.idx % (n / burstCount)) / (n / burstCount);
            const centers = [{x:0.25,y:0.25},{x:0.75,y:0.25},{x:0.5,y:0.5},{x:0.25,y:0.75},{x:0.75,y:0.75},{x:0.15,y:0.5},{x:0.85,y:0.5},{x:0.5,y:0.15}];
            el.data = { burst, cx: centers[burst % 8].x, cy: centers[burst % 8].y, angle: pos * TAU, spd: 0.3 + pos * 0.7, life: pos }; },
        update: (el, t, n) => { const d = el.data, burstT = (t * 0.6 + d.burst * 0.5) % 3;
            let expand = (burstT < 2 ? burstT * 0.15 : (3 - burstT) * 0.3) * cfg.motion.waveInt;
            const spiralAng = d.angle + burstT * d.spd * 2, fade = burstT < 2 ? (1 - burstT / 2) : 0;
            return { x: d.cx + cos(spiralAng) * expand * d.spd, y: d.cy + sin(spiralAng) * expand * d.spd + burstT * burstT * 0.02,
                rot: spiralAng * 50 + t * 100, scale: (0.4 + fade * 0.6 + sin(t * 4 + d.life * 10) * 0.2) * d.spd }; }
    },
    waves: { name: "Wave Interference", count: 2500, baseSize: 32,
        init: (el, n) => { const gridSz = floor(sqrt(n)), row = floor(el.idx / gridSz), col = el.idx % gridSz, span = 1.1, off = (1 - span) / 2;
            el.data = { baseX: (col / (gridSz - 1)) * span + off, baseY: (row / (gridSz - 1)) * span + off }; },
        update: (el, t, n) => { const d = el.data, int = cfg.motion.waveInt * 0.6;
            const dist1 = sqrt(pow(d.baseX - 0.3, 2) + pow(d.baseY - 0.5, 2)), dist2 = sqrt(pow(d.baseX - 0.7, 2) + pow(d.baseY - 0.5, 2));
            const interference = (sin(t * 2.5 - dist1 * 15) * int + sin(t * 2.5 - dist2 * 15 + PI/3) * int) / 2;
            return { x: d.baseX + sin(t * 1.2 + interference * PI) * 0.018, y: d.baseY + interference * 0.035,
                rot: t * 15 + interference * 60 + sin(t * 2) * 20, scale: 0.35 + (interference + 1) * 0.15 + sin(t * 3 + el.idx * 0.1) * 0.08 }; }
    },
    helix: { name: "DNA Helix", count: 1000, baseSize: 38,
        init: (el, n) => { el.data = { strand: el.idx % 2, pos: floor(el.idx / 2) / floor(n / 2) }; },
        update: (el, t, n) => { const d = el.data, helixAng = d.pos * PI * 4 + t * 0.4 + d.strand * PI;
            const breathe = 1 + sin(t * 0.3) * cfg.motion.breathing * 0.3, rWiggle = (0.18 + sin(t * 1.5 + d.pos * 5) * 0.02) * breathe;
            return { x: 0.5 + cos(helixAng) * rWiggle + sin(t * 2 + d.pos * 10) * 0.03 * cfg.motion.waveInt, y: 0.02 + d.pos * 0.96,
                rot: helixAng * 50 + t * 30, scale: 0.4 + sin(d.pos * 8 + t * 2) * 0.2 + sin(t * 3 + d.strand * PI) * 0.15 }; }
    },
    vortex: { name: "Vortex", count: 2000, baseSize: 26,
        init: (el, n) => { el.data = { height: el.idx / n, baseAngle: (el.idx / n) * TAU * 8, rMod: 0.8 + random() * 0.4 }; },
        update: (el, t, n) => { const d = el.data, spin = t * (0.3 + d.height * 0.5), ang = d.baseAngle + spin;
            const r = (((1 - d.height) * 0.4 + 0.05) * d.rMod) * (1 + sin(t * 0.3) * cfg.motion.breathing * 0.2) + sin(t * 1.5 + d.height * 10) * 0.02 * cfg.motion.waveInt;
            return { x: 0.5 + cos(ang) * r, y: 0.02 + d.height * 0.96, rot: ang * 30 + t * 15, scale: 0.3 + (1 - d.height) * 0.4 }; }
    },
    mandala: { name: "Mandala", count: 2160, baseSize: 30,
        init: (el, n) => { const sym = 6, seg = el.idx % sym, inSeg = floor(el.idx / sym), layer = floor(inSeg / 20);
            el.data = { seg, layer, inLayer: (inSeg % 20) / 20, baseR: 0.05 + layer * 0.045, sym }; },
        update: (el, t, n) => { const d = el.data, layerSpin = t * (0.5 - d.layer * 0.05) * (d.layer % 2 === 0 ? 1 : -1);
            const ang = (d.seg / d.sym) * TAU + d.inLayer * TAU / d.sym + layerSpin;
            const r = (d.baseR + sin(t * 2 + d.layer * PI/3) * 0.02 * cfg.motion.waveInt) * (1 + sin(t * 0.4 + d.layer * 0.5) * cfg.motion.breathing * 0.15);
            return { x: 0.5 + cos(ang) * r, y: 0.5 + sin(ang) * r, rot: layerSpin * 80 + d.layer * 30, scale: 0.4 + sin(t * 3 + d.layer) * 0.15 }; }
    },
    constellation: { name: "Constellation", count: 1500, baseSize: 22,
        init: (el, n) => { const cluster = floor(random() * 12), cx = (cluster % 4) / 3 * 0.7 + 0.15, cy = floor(cluster / 4) / 2 * 0.7 + 0.15;
            el.data = { baseX: cx + (random() - 0.5) * 0.25, baseY: cy + (random() - 0.5) * 0.25, twinkleSpd: 2 + random() * 3, driftAng: random() * TAU, driftSpd: 0.005 + random() * 0.01 }; },
        update: (el, t, n) => { const d = el.data;
            return { x: d.baseX + sin(t * d.driftSpd + d.driftAng) * 0.03 * cfg.motion.waveInt, y: d.baseY + cos(t * d.driftSpd * 0.7 + d.driftAng) * 0.02,
                rot: t * 10 + sin(t + el.idx) * 20, scale: 0.3 + (sin(t * d.twinkleSpd + el.phase) * 0.5 + 0.5) * 0.5 }; }
    },
    sailboat: { name: "Sailboat", count: 2000, baseSize: 28, customBg: true,
        init: (el, n) => { boatScene.init(n); },
        update: (el, t, n) => { return boatScene.update(el.idx, t); },
        drawBg: (t) => { boatScene.drawBg(t); }
    }
};

const patternKeys = Object.keys(patterns);

// perf
let liteMode = 'auto', frameTimes = [], perfChecked = false, badFrames = 0;
const FULL_COUNT = 2000, LITE_COUNT = 800;
const isPhone = /iPhone|Android.*Mobile|Mobile.*Android/i.test(navigator.userAgent);
let liteActive = isPhone;
if (liteActive) { console.log('lite mode (phone)'); perfChecked = true; }

function getCount() { return liteActive ? LITE_COUNT : FULL_COUNT; }

function checkPerf() {
    if (perfChecked || liteMode !== 'auto') return;
    if (frameTimes.length >= 10) {
        const fps = 1000 / (frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length);
        if (fps < 30) { badFrames++; if (badFrames >= 2) { console.log(`auto lite (${fps.toFixed(1)} fps)`); liteActive = true; reinit(); updateLiteBtn(); perfChecked = true; } }
        else { console.log(`perf ok (${fps.toFixed(1)} fps)`); perfChecked = true; }
        frameTimes = [];
    }
}

function toggleLite() {
    if (liteMode === 'auto') { liteMode = 'on'; liteActive = true; }
    else if (liteMode === 'on') { liteMode = 'off'; liteActive = false; }
    else { liteMode = 'auto'; liteActive = false; perfChecked = false; frameTimes = []; }
    reinit(); updateLiteBtn();
}

function updateLiteBtn() {
    const btn = document.getElementById('lite-btn');
    if (btn) { btn.textContent = liteMode === 'auto' ? `Lite: AUTO${liteActive ? ' (ON)' : ''}` : `Lite: ${liteMode.toUpperCase()}`; btn.classList.toggle('active', liteActive); }
}

function reinit() {
    const n = getCount(); makeElements(n);
    elements.forEach(el => patterns[patternKeys[curPattern]].init(el, n));
}

function initPattern(key) { const n = getCount(); if (elements.length !== n) makeElements(n); elements.forEach(el => patterns[key].init(el, n)); }

function switchTo(idx, smooth = true) {
    const newIdx = ((idx % patternKeys.length) + patternKeys.length) % patternKeys.length;
    if (newIdx === curPattern) return;
    const n = getCount();
    if (smooth && elements.length > 0) {
        const t = performance.now() / 1000 * cfg.timeScale;
        elements.forEach(el => { const pos = patterns[patternKeys[curPattern]].update(el, t, n); el.prevPos = { x: pos.x, y: pos.y, rot: pos.rot, scale: pos.scale }; });
        transitionProg = 0; transitionStart = performance.now() / 1000;
    }
    curPattern = newIdx; elements.forEach(el => patterns[patternKeys[curPattern]].init(el, n)); showName(patterns[patternKeys[curPattern]].name);
}

function nextPattern() { switchTo(curPattern + 1, true); }
function prevPattern() { switchTo(curPattern - 1, true); }
function randomPattern() { let next; do { next = floor(random() * patternKeys.length); } while (next === curPattern && patternKeys.length > 1); switchTo(next, true); }

function showName(name) { const el = document.getElementById('pattern-name'); el.textContent = name; el.classList.add('visible'); setTimeout(() => el.classList.remove('visible'), 3000); }

// wildcards
const wildcards = [
    { name: "Calm Ocean", color: { speed: 0.02, hueOffset: 0.55, sat: 0.6 }, motion: { waveInt: 0.5, breathing: 0.4, chaos: 0 } },
    { name: "Fire Storm", color: { speed: 0.05, hueOffset: 0.0, spread: 0.2, sat: 0.9 }, motion: { chaos: 0.08, waveInt: 0.7 } },
    { name: "Ethereal", color: { speed: 0.015, sat: 0.45, val: 1.0 }, visual: { baseAlpha: 0.6, twinkleAmt: 0.25 }, motion: { chaos: 0 } },
    { name: "Hyperdrive", timeScale: 1.2, color: { speed: 0.07 }, motion: { waveInt: 0.8, chaos: 0 } },
    { name: "Meditation", timeScale: 0.7, color: { speed: 0.02 }, motion: { breathing: 0.5, chaos: 0, waveInt: 0.4 } },
    { name: "Disco", color: { speed: 0.09, spread: 1.3 }, visual: { pulseSpeed: 0.5, pulseAmt: 0.12 }, motion: { chaos: 0 } },
    { name: "Nebula", color: { hueOffset: 0.75, sat: 0.7, spread: 0.35 }, motion: { breathing: 0.4, chaos: 0 } },
    { name: "Gentle Flow", motion: { chaos: 0.05, waveInt: 0.6 }, timeScale: 0.9 }
];

let timeOffset = 0; // Added time offset for wildcard jumps

function applyWildcard() {
    // Jump to a random point in time - this is what makes the spiral look different
    timeOffset = random() * 10000; // 0-10000 seconds of offset
    
    // Also randomize some visual params
    cfg.color.hueOffset = random();
    cfg.color.speed = round3(0.02 + random() * 0.06);
    cfg.spiral.rotSpeed = round3(0.0008 + random() * 0.002);
    cfg.spiral.wiggleAmp = round3(0.1 + random() * 0.25);
    
    console.log("wildcard: time jump to t+" + timeOffset.toFixed(0));
}

let cycleTimer = null;
function toggleAuto() {
    cfg.autoCycle = !cfg.autoCycle;
    document.getElementById('auto-btn').textContent = `Auto: ${cfg.autoCycle ? 'ON' : 'OFF'}`;
    document.getElementById('auto-btn').classList.toggle('active', cfg.autoCycle);
    if (cfg.autoCycle) cycleTimer = setInterval(() => { nextPattern(); if (random() > 0.6) applyWildcard(); }, cfg.cycleInterval);
    else clearInterval(cycleTimer);
}

function getMouseFx(px, py) {
    if (!mouse.active) return { push: { x: 0, y: 0 }, hueShift: 0 };
    const dx = px - mouse.x, dy = py - mouse.y, dist = sqrt(dx * dx + dy * dy), r = cfg.mouse.radius;
    if (dist < r && dist > 0.001) { const t = 1 - dist / r, infl = t * t * t * cfg.mouse.push;
        return { push: { x: (dx / dist) * infl, y: (dy / dist) * infl }, hueShift: t * t * cfg.mouse.hueShift }; }
    return { push: { x: 0, y: 0 }, hueShift: 0 };
}

// main render loop
let lastFrame = 0;

function render(ts) {
    if (lastFrame > 0) { frameTimes.push(ts - lastFrame); if (frameTimes.length > 120) frameTimes.shift(); checkPerf(); }
    lastFrame = ts;
    const t = (ts / 1000) * cfg.timeScale + timeOffset;
    mouse.x = lerp(mouse.x, mouseTarget.x, 0.1); mouse.y = lerp(mouse.y, mouseTarget.y, 0.1);
    
    // background
    const pat = patterns[patternKeys[curPattern]];
    const baseSize = pat.baseSize || 28;
    if (pat.customBg && pat.drawBg) pat.drawBg(t);
    else if (!liteActive || ts % 2 < 1) drawBg(t);
    
    // clear WebGL
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    const n = elements.length;
    const basePulse = 1 + sin(t * cfg.visual.pulseSpeed) * cfg.visual.pulseAmt;
    const globalTwinkle = sin(t * cfg.visual.twinkleSpeed * 0.5) * 0.5 + 0.5;
    
    if (transitionProg < 1) { transitionProg = min(1, (ts / 1000 - transitionStart) / cfg.transition.dur); }
    const tEase = easeInOut(transitionProg);
    
    // text blend
    let textBlend = 0;
    if (textActive) {
        const elapsed = ts / 1000 - textStart, total = TEXT_FORM_DUR + TEXT_HOLD_DUR + TEXT_RELEASE_DUR;
        if (elapsed < TEXT_FORM_DUR) textBlend = easeInOut(elapsed / TEXT_FORM_DUR);
        else if (elapsed < TEXT_FORM_DUR + TEXT_HOLD_DUR) textBlend = 1;
        else if (elapsed < total) textBlend = 1 - easeInOut((elapsed - TEXT_FORM_DUR - TEXT_HOLD_DUR) / TEXT_RELEASE_DUR);
        else { textActive = false; textBlend = 0; }
    }
    
    // update instance data
    let count = 0;
    for (let i = 0; i < n && count < MAX_PARTICLES; i++) {
        const el = elements[i];
        let pos = pat.update(el, t, n);
        if (!pos || pos.scale < 0.01) continue;
        
        // transition blend
        if (transitionProg < 1 && el.prevPos) {
            pos = { x: lerp(el.prevPos.x, pos.x, tEase), y: lerp(el.prevPos.y, pos.y, tEase), rot: lerp(el.prevPos.rot || 0, pos.rot || 0, tEase), scale: lerp(el.prevPos.scale, pos.scale, tEase), hue: pos.hue, sat: pos.sat, val: pos.val, alpha: pos.alpha };
        }
        
        // text blend
        if (textBlend > 0 && textPts[i]) {
            const pt = textPts[i];
            if (pt.type === 'mandala') {
                const curAng = pt.baseAngle + t * pt.rotSpd, curR = pt.baseRadius + sin(t * pt.pulseSpd + pt.baseAngle) * pt.pulseAmt + sin(t * 3 + pt.baseAngle * 3) * 0.008;
                const mx = 0.5 + cos(curAng) * curR, my = 0.5 + sin(curAng) * curR + cos(t * 2.5 + pt.baseAngle * 2) * 0.01;
                pos = { x: lerp(pos.x, mx, textBlend), y: lerp(pos.y, my, textBlend), scale: lerp(pos.scale, 0.35 - pt.ring * 0.03 + sin(t * 2 + pt.baseAngle) * 0.08, textBlend), rot: lerp(pos.rot || 0, curAng * 80 + t * 60 + pt.ring * 30, textBlend), hue: pos.hue, sat: pos.sat, val: pos.val, alpha: pos.alpha };
            } else {
                const tScale = textTarget === 'SAT2' ? 0.38 : 0.28;
                pos = { x: lerp(pos.x, pt.x + sin(t * 1.5 + pt.wave) * 0.004 * textBlend, textBlend), y: lerp(pos.y, pt.y + pt.depth * sin(t * 1.2) * textBlend, textBlend), scale: lerp(pos.scale, tScale, textBlend), rot: lerp(pos.rot || 0, sin(t * 0.5 + pt.wave) * 8, textBlend), hue: pos.hue, sat: pos.sat, val: pos.val, alpha: pos.alpha };
            }
        }
        
        // mouse
        const mfx = getMouseFx(pos.x, pos.y);
        pos.x += mfx.push.x; pos.y += mfx.push.y;
        
        // compute final color
        let hue, sat, val, alpha;
        if (pos.hue !== undefined) {
            hue = (pos.hue + mfx.hueShift) % 1;
            sat = pos.sat !== undefined ? pos.sat : cfg.color.sat;
            val = pos.val !== undefined ? pos.val : cfg.color.val;
            alpha = pos.alpha !== undefined ? pos.alpha : cfg.visual.baseAlpha;
        } else {
            if (textBlend > 0 && textPts[i] && textPts[i].type === 'mandala') {
                const pt = textPts[i], ringHue = (pt.baseAngle / TAU + t * 0.1 + pt.ring * 0.15) % 1;
                hue = lerp((t * cfg.color.speed + cfg.color.hueOffset + (i / n) * cfg.color.spread + el.colorOff) % 1, ringHue, textBlend);
            } else hue = (t * cfg.color.speed + cfg.color.hueOffset + (i / n) * cfg.color.spread + el.colorOff) % 1;
            hue = (hue + mfx.hueShift) % 1;
            sat = cfg.color.sat;
            val = cfg.color.val;
            const twinkle = 1 - ((sin(t * cfg.visual.twinkleSpeed + el.twinklePhase) * 0.5 + 0.5) * globalTwinkle * cfg.visual.twinkleAmt);
            alpha = clamp(cfg.visual.baseAlpha * twinkle, 0.2, 1.0);
            if (textBlend > 0 && textPts[i] && textPts[i].type === 'mandala') alpha = clamp(alpha * (1 + textBlend * 0.3), 0.2, 1.0);
        }
        
        const finalScale = clamp(pos.scale * el.sizeVar * basePulse, 0.15, 1.5);
        if (alpha < 0.01) continue;
        
        // pack into buffer: x, y, rot, scale, hue, alpha, sat, val
        const off = count * 8;
        instData[off] = pos.x;
        instData[off + 1] = pos.y;
        instData[off + 2] = (pos.rot || 0) * PI / 180;
        instData[off + 3] = finalScale * baseSize * scale;
        instData[off + 4] = hue;
        instData[off + 5] = alpha;
        instData[off + 6] = sat;
        instData[off + 7] = val;
        count++;
    }
    
    // upload and draw
    gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, instData.subarray(0, count * 8));
    
    gl.useProgram(prog);
    gl.uniform2f(uRes, w, h);
    
    gl.bindVertexArray(vao);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, count);
    gl.bindVertexArray(null);
    
    requestAnimationFrame(render);
}

// ui
let uiVisible = true;
document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('click', e => {
        e.stopPropagation();
        switch(btn.dataset.action) {
            case 'prev': prevPattern(); break;
            case 'next': nextPattern(); break;
            case 'random': randomPattern(); break;
            case 'wildcard': applyWildcard(); break;
            case 'hide': uiVisible = !uiVisible; document.getElementById('info').classList.toggle('hidden', !uiVisible); document.querySelector('.mouse-hint').classList.toggle('hidden', !uiVisible); break;
            case 'sat2': triggerText('SAT2'); break;
            case 'auto': toggleAuto(); break;
            case 'lite': toggleLite(); break;
        }
    });
});

document.addEventListener('keydown', e => {
    switch(e.key.toLowerCase()) {
        case ' ': case 'arrowright': e.preventDefault(); nextPattern(); break;
        case 'arrowleft': e.preventDefault(); prevPattern(); break;
        case 'r': randomPattern(); break;
        case 'w': applyWildcard(); break;
        case 'h': uiVisible = !uiVisible; document.getElementById('info').classList.toggle('hidden', !uiVisible); document.querySelector('.mouse-hint').classList.toggle('hidden', !uiVisible); break;
        case 'a': toggleAuto(); break;
        case 'l': toggleLite(); break;
        case 'p': console.log('cfg:', JSON.stringify(cfg, null, 2)); break;
    }
});

// init
curPattern = floor(random() * patternKeys.length);
initPattern(patternKeys[curPattern]);
updateLiteBtn();
requestAnimationFrame(render);
console.log("WebGL ready - " + patternKeys.length + " patterns, arrows to navigate, R for random");
    </script>
</body>
</html>
